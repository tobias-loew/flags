<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.21">
<meta name="author" content="Tobias Loew">
<title>Boost.Flags</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>
pre.rouge table td { padding: 5px; }
pre.rouge table pre { margin: 0; }
pre.rouge, pre.rouge .w {
  color: #24292f;
  background-color: #f6f8fa;
}
pre.rouge .k, pre.rouge .kd, pre.rouge .kn, pre.rouge .kp, pre.rouge .kr, pre.rouge .kt, pre.rouge .kv {
  color: #cf222e;
}
pre.rouge .gr {
  color: #f6f8fa;
}
pre.rouge .gd {
  color: #82071e;
  background-color: #ffebe9;
}
pre.rouge .nb {
  color: #953800;
}
pre.rouge .nc {
  color: #953800;
}
pre.rouge .no {
  color: #953800;
}
pre.rouge .nn {
  color: #953800;
}
pre.rouge .sr {
  color: #116329;
}
pre.rouge .na {
  color: #116329;
}
pre.rouge .nt {
  color: #116329;
}
pre.rouge .gi {
  color: #116329;
  background-color: #dafbe1;
}
pre.rouge .kc {
  color: #0550ae;
}
pre.rouge .l, pre.rouge .ld, pre.rouge .m, pre.rouge .mb, pre.rouge .mf, pre.rouge .mh, pre.rouge .mi, pre.rouge .il, pre.rouge .mo, pre.rouge .mx {
  color: #0550ae;
}
pre.rouge .sb {
  color: #0550ae;
}
pre.rouge .bp {
  color: #0550ae;
}
pre.rouge .ne {
  color: #0550ae;
}
pre.rouge .nl {
  color: #0550ae;
}
pre.rouge .py {
  color: #0550ae;
}
pre.rouge .nv, pre.rouge .vc, pre.rouge .vg, pre.rouge .vi, pre.rouge .vm {
  color: #0550ae;
}
pre.rouge .o, pre.rouge .ow {
  color: #0550ae;
}
pre.rouge .gh {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .gu {
  color: #0550ae;
  font-weight: bold;
}
pre.rouge .s, pre.rouge .sa, pre.rouge .sc, pre.rouge .dl, pre.rouge .sd, pre.rouge .s2, pre.rouge .se, pre.rouge .sh, pre.rouge .sx, pre.rouge .s1, pre.rouge .ss {
  color: #0a3069;
}
pre.rouge .nd {
  color: #8250df;
}
pre.rouge .nf, pre.rouge .fm {
  color: #8250df;
}
pre.rouge .err {
  color: #f6f8fa;
  background-color: #82071e;
}
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cm, pre.rouge .cp, pre.rouge .cpf, pre.rouge .c1, pre.rouge .cs {
  color: #6e7781;
}
pre.rouge .gl {
  color: #6e7781;
}
pre.rouge .gt {
  color: #6e7781;
}
pre.rouge .ni {
  color: #24292f;
}
pre.rouge .si {
  color: #24292f;
}
pre.rouge .ge {
  color: #24292f;
  font-style: italic;
}
pre.rouge .gs {
  color: #24292f;
  font-weight: bold;
}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Boost.Flags</h1>
<div class="details">
<span id="author" class="author">Tobias Loew</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#description">Type-safe bitwise operations - TL;DR</a>
<ul class="sectlevel2">
<li><a href="#how_to_use_boost_flags">How to use Boost.Flags?</a></li>
<li><a href="#why_use_boost_flags">Why use Boost.Flags?</a></li>
<li><a href="#characteristics_of_boost_flags">Characteristics of Boost.Flags</a></li>
<li><a href="#opt_in">Opt-in</a></li>
<li><a href="#scoped_or_unscoped_enumerations"><em>scoped</em> or <em>unscoped</em> enumerations?</a></li>
<li><a href="#what_about_the_underlying_type">What about the underlying type?</a></li>
</ul>
</li>
<li><a href="#the_long_story">The long story</a>
<ul class="sectlevel2">
<li><a href="#type_safety">Type-Safety</a></li>
<li><a href="#underlying_type">The underlying type</a></li>
<li><a href="#complementing_the_complement">Complementing the <code>complement</code></a></li>
<li><a href="#mathematical_justification_for_complement">Mathematical justification for <code>complement</code></a></li>
<li><a href="#from_flags_to_bool">From flags to <code>bool</code></a></li>
<li><a href="#not_not"><code>not</code>, <code>not not</code>, why not?</a></li>
<li><a href="#everything_in_order">Everything in order?</a></li>
<li><a href="#flags_and_flags">Flags <code>and</code> Flags</a></li>
<li><a href="#logically_and_and_or">Logically <code>and</code> and <code>or</code></a></li>
</ul>
</li>
<li><a href="#utilities">Utilities</a>
<ul class="sectlevel2">
<li><a href="#functions">Functions</a></li>
<li><a href="#flags_generator">Flags generator</a></li>
</ul>
</li>
<li><a href="#other_implementations">Other flags-like enum implementations</a></li>
<li><a href="#design_rationale">Design rationale</a></li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#supported_language_versions">Supported language versions</a></li>
<li><a href="#opt_in_2">Opt-in</a>
<ul class="sectlevel3">
<li><a href="#boost_flags_enable">boost_flags_enable</a></li>
</ul>
</li>
<li><a href="#types">Types</a>
<ul class="sectlevel3">
<li><a href="#enablet">enable&lt;T&gt;</a></li>
<li><a href="#complementt">complement&lt;T&gt;</a></li>
<li><a href="#disable_complement">disable_complement</a></li>
<li><a href="#logical_and">logical_and</a></li>
<li><a href="#total_order_t">total_order_t</a></li>
<li><a href="#partial_order_t">partial_order_t</a></li>
</ul>
</li>
<li><a href="#operators">Operators</a>
<ul class="sectlevel3">
<li><a href="#negation_operation">operator~</a></li>
<li><a href="#operator">operator&amp;</a></li>
<li><a href="#operator_2">operator|</a></li>
<li><a href="#operator_3">operator^</a></li>
<li><a href="#operator_4">operator&amp;=</a></li>
<li><a href="#operator_5">operator|=</a></li>
<li><a href="#operator_6">operator^=</a></li>
<li><a href="#operator_7">operator!</a></li>
<li><a href="#pseudo_operator_boost_flags_and">Pseudo operator BOOST_FLAGS_AND</a></li>
</ul>
</li>
<li><a href="#operator_operator">operator== , operator!=</a></li>
<li><a href="#relational_operators_and">Relational operators &lt;, &lt;=, &gt; and &gt;=</a></li>
<li><a href="#boolean_predicates">Boolean predicates</a>
<ul class="sectlevel3">
<li><a href="#any">any</a></li>
<li><a href="#none">none</a></li>
<li><a href="#intersect">intersect</a></li>
<li><a href="#disjoint">disjoint</a></li>
<li><a href="#subseteq">subseteq</a></li>
<li><a href="#subset">subset</a></li>
</ul>
</li>
<li><a href="#utility_functions">Utility functions</a>
<ul class="sectlevel3">
<li><a href="#make_null">make_null</a></li>
<li><a href="#make_if">make_if</a></li>
<li><a href="#modify">modify</a></li>
<li><a href="#modify_inplace">modify_inplace</a></li>
<li><a href="#add_if">add_if</a></li>
<li><a href="#add_if_inplace">add_if_inplace</a></li>
<li><a href="#remove_if">remove_if</a></li>
<li><a href="#remove_if_inplace">remove_if_inplace</a></li>
<li><a href="#get_underlying">get_underlying</a></li>
<li><a href="#from_underlying">from_underlying</a></li>
<li><a href="#nth_bit">nth_bit</a></li>
<li><a href="#next_bit">next_bit</a></li>
</ul>
</li>
<li><a href="#flags_generator_2">Flags generator</a>
<ul class="sectlevel3">
<li><a href="#flag_generator">flag_generator</a></li>
<li><a href="#flags_from_to">flags_from_to</a></li>
<li><a href="#flags_to">flags_to</a></li>
<li><a href="#flags_all">flags_all</a></li>
</ul>
</li>
<li><a href="#macros">Macros</a>
<ul class="sectlevel3">
<li><a href="#boost_flags_null">BOOST_FLAGS_NULL</a></li>
<li><a href="#boost_flags_rel_ops_delete">BOOST_FLAGS_REL_OPS_DELETE</a></li>
<li><a href="#boost_flags_specialize_std_less">BOOST_FLAGS_SPECIALIZE_STD_LESS</a></li>
<li><a href="#boost_flags_rel_ops_partial_order">BOOST_FLAGS_REL_OPS_PARTIAL_ORDER</a></li>
<li><a href="#boost_flags_specialize_std_less_2">BOOST_FLAGS_SPECIALIZE_STD_LESS</a></li>
</ul>
</li>
<li><a href="#configuration_macros">Configuration Macros</a>
<ul class="sectlevel3">
<li><a href="#boost_flags_has_three_way_comparison">BOOST_FLAGS_HAS_THREE_WAY_COMPARISON</a></li>
<li><a href="#boost_flags_has_partial_ordering">BOOST_FLAGS_HAS_PARTIAL_ORDERING</a></li>
<li><a href="#boost_flags_has_concepts">BOOST_FLAGS_HAS_CONCEPTS</a></li>
<li><a href="#boost_flags_has_is_scoped_enum">BOOST_FLAGS_HAS_IS_SCOPED_ENUM</a></li>
<li><a href="#boost_flags_has_logical_traits">BOOST_FLAGS_HAS_LOGICAL_TRAITS</a></li>
<li><a href="#boost_flags_has_inline_variables">BOOST_FLAGS_HAS_INLINE_VARIABLES</a></li>
<li><a href="#boost_flags_define_partial_ordering_objects">BOOST_FLAGS_DEFINE_PARTIAL_ORDERING_OBJECTS</a></li>
<li><a href="#boost_flags_has_rewritten_candidates">BOOST_FLAGS_HAS_REWRITTEN_CANDIDATES</a></li>
<li><a href="#boost_flags_weak_symbol">BOOST_FLAGS_WEAK_SYMBOL</a></li>
<li><a href="#boost_flags_attribute_nodiscard">BOOST_FLAGS_ATTRIBUTE_NODISCARD</a></li>
<li><a href="#boost_flags_attribute_nodiscard_ctor">BOOST_FLAGS_ATTRIBUTE_NODISCARD_CTOR</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#copyright_and_license">Appendix A: Copyright and License</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="description">Type-safe bitwise operations - TL;DR</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="how_to_use_boost_flags">How to use Boost.Flags?</h3>
<div class="ulist">
<ul>
<li>
<p>include the header <code>&lt;boost/flags.hpp&gt;</code></p>
</li>
<li>
<p>opt-in for an enumeration <code>E</code> by defining</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">boost_flags_enable</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>in the same namespace as <code>E</code>.</p>
</div>
<div class="paragraph">
<p>Example:  <a href="https://godbolt.org/z/4efs43hYn" target="_blank" rel="noopener">on Godbolt compiler explorer</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;boost/flags.hpp&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">pizza_toppings</span> <span class="o">:</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">tomato</span>       <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">nth_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="c1">// == 0x01</span>
    <span class="n">cheese</span>       <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">nth_bit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="c1">// == 0x02</span>
    <span class="n">salami</span>       <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">nth_bit</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="c1">// == 0x04</span>
    <span class="n">olives</span>       <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">nth_bit</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="c1">// == 0x08</span>
    <span class="n">garlic</span>       <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">nth_bit</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="c1">// == 0x10</span>

    <span class="n">all_toppings</span> <span class="o">=</span> <span class="n">tomato</span> <span class="o">|</span> <span class="n">cheese</span> <span class="o">|</span> <span class="n">salami</span> <span class="o">|</span> <span class="n">olives</span> <span class="o">|</span> <span class="n">garlic</span><span class="p">,</span>
<span class="p">};</span>
<span class="c1">// enable Boost.Flags for pizza_toppings</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">boost_flags_enable</span><span class="p">(</span><span class="n">pizza_toppings</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">ice_cream_flavours</span> <span class="o">:</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">vanilla</span>      <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">nth_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="c1">// == 0x01</span>
    <span class="n">chocolate</span>    <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">nth_bit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="c1">// == 0x02</span>
    <span class="n">strawberry</span>   <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">nth_bit</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="c1">// == 0x04</span>
<span class="p">};</span>
<span class="c1">// enable Boost.Flags for ice_cream_flavours</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">boost_flags_enable</span><span class="p">(</span><span class="n">ice_cream_flavours</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// order selected pizza</span>
<span class="kt">void</span> <span class="nf">order_pizza</span><span class="p">(</span><span class="n">pizza_toppings</span> <span class="n">toppings</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Pizza ordered with</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">toppings</span> <span class="o">&amp;</span> <span class="n">pizza_toppings</span><span class="o">::</span><span class="n">tomato</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- tomato</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">toppings</span> <span class="o">&amp;</span> <span class="n">pizza_toppings</span><span class="o">::</span><span class="n">cheese</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- cheese</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">toppings</span> <span class="o">&amp;</span> <span class="n">pizza_toppings</span><span class="o">::</span><span class="n">salami</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- salami</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">toppings</span> <span class="o">&amp;</span> <span class="n">pizza_toppings</span><span class="o">::</span><span class="n">olives</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- olives</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">toppings</span> <span class="o">&amp;</span> <span class="n">pizza_toppings</span><span class="o">::</span><span class="n">garlic</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- garlic</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// order selected dessert</span>
<span class="kt">void</span> <span class="nf">order_ice_cream</span><span class="p">(</span><span class="n">ice_cream_flavours</span> <span class="n">flavours</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ice cream ordered with flavours</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">flavours</span> <span class="o">&amp;</span> <span class="n">ice_cream_flavours</span><span class="o">::</span><span class="n">vanilla</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- vanilla</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">flavours</span> <span class="o">&amp;</span> <span class="n">ice_cream_flavours</span><span class="o">::</span><span class="n">chocolate</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- chocolate</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">flavours</span> <span class="o">&amp;</span> <span class="n">ice_cream_flavours</span><span class="o">::</span><span class="n">strawberry</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"- strawberry</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pizza_toppings</span> <span class="n">toppings</span> <span class="o">=</span> <span class="n">pizza_toppings</span><span class="o">::</span><span class="n">tomato</span> <span class="o">|</span> <span class="n">pizza_toppings</span><span class="o">::</span><span class="n">cheese</span><span class="p">;</span> <span class="c1">// a decent start</span>
    <span class="n">toppings</span> <span class="o">|=</span> <span class="n">pizza_toppings</span><span class="o">::</span><span class="n">salami</span> <span class="o">|</span> <span class="n">pizza_toppings</span><span class="o">::</span><span class="n">olives</span><span class="p">;</span>    <span class="c1">// even better</span>
    <span class="n">order_pizza</span><span class="p">(</span><span class="n">toppings</span><span class="p">);</span>                              <span class="c1">// order main course</span>
    <span class="n">order_pizza</span><span class="p">(</span><span class="n">toppings</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pizza_toppings</span><span class="o">::</span><span class="n">salami</span><span class="p">);</span>    <span class="c1">// order a vegetarian pizza</span>
    <span class="n">order_ice_cream</span><span class="p">(</span><span class="n">ice_cream_flavours</span><span class="o">::</span><span class="n">vanilla</span><span class="p">);</span>       <span class="c1">// order desert</span>

    <span class="c1">// Guest: "Pizza without olives!"</span>
    <span class="c1">// Waiter: "Ok, no olives. But what else to put on it?"</span>
    <span class="c1">// error: negative mask is not a pizza topping</span>
    <span style="text-decoration: red wavy underline; text-decoration-skip-ink: none;">order_pizza(~pizza_toppings::olives);</span>

    <span class="c1">// Guest: "Pizza with all toppings but olives!"</span>
    <span class="c1">// Waiter: "Ok, got it!"</span>
    <span class="c1">// Waiter takes note: Pizza with tomato, cheese, salami, garlic.</span>
    <span class="n">order_pizza</span><span class="p">(</span><span class="n">pizza_toppings</span><span class="o">::</span><span class="n">all_toppings</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">pizza_toppings</span><span class="o">::</span><span class="n">olives</span><span class="p">);</span>

    <span class="c1">// error: mixing different enumerations</span>
    <span style="text-decoration: red wavy underline; text-decoration-skip-ink: none;">toppings |= ice_cream_flavours::strawberry;</span>

    <span class="c1">// error: called with wrong enumeration</span>
    <span style="text-decoration: red wavy underline; text-decoration-skip-ink: none;">order_ice_cream(toppings);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="why_use_boost_flags">Why use Boost.Flags?</h3>
<div class="ulist">
<ul>
<li>
<p>provides type-safe bitwise operations for flag-like scoped / unscoped enumerations</p>
</li>
<li>
<p>turns undetected logical errors into type errors</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="characteristics_of_boost_flags">Characteristics of Boost.Flags</h3>
<div class="ulist">
<ul>
<li>
<p>is non-intrusive - only a function overload or a template specializations required to opt-in</p>
</li>
<li>
<p>single header-file library</p>
</li>
<li>
<p>no dependencies (only standard-library includes)</p>
</li>
<li>
<p>everything is <code>constexpr</code></p>
</li>
<li>
<p>zero-overhead in optimized builds</p>
</li>
<li>
<p>requires at least C++11, uses newer features if available</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="opt_in">Opt-in</h3>
<div class="paragraph">
<p>To opt-in to Boost.Flags for an enumeration <code>E</code> the easiest and most comfortable way is to overload <code>boost_flags_enable</code> for <code>E</code> in the same namespace as <code>E</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">boost_flags_enable</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As Boost.Flags will call <code>boost_flags_enable</code> unqualified, it will be looked up using <a href="https://en.cppreference.com/w/cpp/language/adl" target="_blank" rel="noopener">ADL</a>.
Best practice would be defining <code>constexpr bool boost_flags_enable(E) { return true; }</code> right after the enumeration in the same namespace.</p>
</div>
<div class="paragraph">
<p>In case the enumeration <code>E</code> is defined inside a class, a <code>friend</code> function can be used for enabling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">class</span> <span class="nc">my_class</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">enum</span> <span class="k">class</span> <span class="nc">E</span><span class="o">:</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
    <span class="k">friend</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">boost_flags_enable</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of defining <code>boost_flags_enable</code> the class template <a href="#types_enable"><code>boost::flags::enable</code></a> can be specialized for enabling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">enable</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>In case you want to ensure that an enumeration is enabled for Boost.Flags, you can test it e.g. with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">static_assert</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">enable</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">"Please check if E is enabled correctly and boost/flags.hpp is included."</span><span class="p">);</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scoped_or_unscoped_enumerations"><em>scoped</em> or <em>unscoped</em> enumerations?</h3>
<div class="paragraph">
<p>The usage of scoped enumeration is strongly recommended, as they provide more type safety than unscoped by prohibiting implicit conversion to the underlying integer type.</p>
</div>
<div class="paragraph">
<p>Nevertheless, for both kinds of enumerations Boost.Flags will detect semantical errors when using bitwise operations.</p>
</div>
<div class="paragraph">
<p>For unscoped enumerations Boost.Flags will delete binary operators <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>==</code> and <code>!=</code> where</p>
</div>
<div class="ulist">
<ul>
<li>
<p>at least one is enabled for Boost.Flags and</p>
</li>
<li>
<p>both arguments are implicitly convertible to an integer type and</p>
</li>
<li>
<p>both arguments are not compatible (they do not derive from the same enumeration)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>i.e. Boost.Flags will prohibit that in those cases the built-in version will be used.<br>
(For scoped enumerations this is not necessary, as those cases cannot occur.)</p>
</div>
</div>
<div class="sect2">
<h3 id="what_about_the_underlying_type">What about the underlying type?</h3>
<div class="ulist">
<ul>
<li>
<p>For <strong>unscoped</strong> enumerations <strong>absolutely REQUIRED</strong>!</p>
</li>
<li>
<p>For language standards <strong>before C++20</strong> as an <code>unsigned</code> type, for both scoped and unscoped enumerations!</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>(For details <a href="#underlying_type">see below.</a>)</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the_long_story">The long story</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Why do we use the bits of integer types for boolean options?</p>
</div>
<div class="ulist">
<ul>
<li>
<p>easy to define, e.g. as macros, integer constants or enumerators</p>
</li>
<li>
<p>language support for setting and querying through bitwise operators</p>
</li>
<li>
<p>compact representation in memory</p>
</li>
<li>
<p>simple bulk transfer in interfaces (on many platforms an <code>int</code> can hold up to 32 different boolean options)</p>
</li>
<li>
<p>enforces the usage of names, especially to prevent <code>bool</code> parameters in interfaces:</p>
<div class="quoteblock">
<blockquote>
Boolean arguments loudly declare that the function does more than one thing. They are confusing and should be eliminated.
</blockquote>
<div class="attribution">
&#8212; C. Martin (Uncle Bob)<br>
<cite>Clean Code</cite>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>C++ has everything needed to work with flags, so why do we need Boost.Flags?</p>
</div>
<div class="paragraph">
<p>Because we can do <strong>too much</strong> with them!</p>
</div>
<div class="sect2">
<h3 id="type_safety">Type-Safety</h3>
<div class="paragraph">
<p>For flags based on integer-types or enumerations all values are implicitly convertible to <code>int</code>. The compiler can&#8217;t help, when we accidentally apply binary operators to unrelated flags.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example from the Win32-API:</p>
</div>
<div class="paragraph">
<p>In <code>Windows.h</code> we find the listbox-style</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#define LBS_NOTIFY            0x0001L</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and the button-style</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#define BS_NOTIFY           0x00004000L</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If we forget the leading <code>L</code> of <code>LBS_NOTIFY</code> and write</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="k">if</span> <span class="p">(</span><span class="n">listbox_styles</span> <span class="o">&amp;</span> <span class="n">BS_NOTIFY</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>instead, we produced syntactically correct code but semantical nonsense.</p>
</div>
<h4 id="switching_to_enumerations_makes_it_even_worse" class="discrete">Switching to enumerations makes it even worse</h4>
<div class="paragraph">
<p>If the Windows team had decided to use unscoped enumerations instead of macros it wouldn&#8217;t have helped: the arguments of built-in bitwise operators are subject to integral promotion, i.e. they forget about the enumeration&#8217;s semantic overhead. Even worse:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The built-in operators <code>&amp;</code>, <code>|</code>, <code>^</code> and <code>~</code> return integer types. Assigning their results to enumeration-type variables require explicit casts, which is another source for errors undetectable by the compiler.</p>
</li>
<li>
<p>The built-in operators <code>&amp;=</code>, <code>|=</code>, <code>^=</code> require the left-hand type to be arithmetic, which excludes enumerations.</p>
</li>
<li>
<p>Scoped enumerations (which didn&#8217;t exist when <code>Windows.h</code> was created) prohibit implicit integral promotion and therefore don&#8217;t work with built-in bitwise operators at all.</p>
</li>
</ul>
</div>
<h4 id="but_enumerations_provide_type_safety" class="discrete">But enumerations provide type-safety</h4>
<div class="paragraph">
<p>On the other hand, enumerations, and especially scoped ones, improve the type-safety of our code:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>variables and arguments of enumeration type can only by assigned (resp. invoked) with a value of the same type</p>
</li>
<li>
<p>no implicit integral promotion for scoped enumerations</p>
</li>
</ul>
</div>
<h4 id="with_boost_flags_you_can_get_both" class="discrete">With Boost.Flags you can get both!</h4>
<div class="paragraph">
<p>With Boost.Flags we get support for all bitwise operators and type-safety. E.g. the following code</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">enum</span> <span class="k">class</span> <span class="nc">E</span> <span class="o">:</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">{</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">8</span> <span class="p">};</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">boost_flags_enable</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>enables all the operators <code>~</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code> for <code>E</code> and <code>complement&lt;E&gt;</code> (<a href="#complementing_the_complement">see below</a>)</p>
</li>
<li>
<p>the binary operators require both arguments to be from the enumeration or its <code>complement</code></p>
</li>
<li>
<p>the bitwise negation <code>~</code> changes the type from <code>E</code> to <code>complement&lt;E&gt;</code> and vice-versa</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="underlying_type">The underlying type</h3>
<div class="paragraph">
<p>Is the the specification of the underlying type required?</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/underlying_type_decision_diagram.png" alt="underlying type decision diagram" width="800" height="448">
</div>
</div>
<div class="paragraph">
<p>Ok, the <code>unsigned</code> is more a theoretical issue, since all C++ compilers already used two&#8217;s complement for signed integers, even before it got mandatory with C++20.</p>
</div>
<div class="paragraph">
<p>Furthermore, scoped enumerations always have a fixed underlying type, which is <code>int</code> if not specified (<a href="https://eel.is/c++draft/dcl.enum#5" class="bare" target="_blank" rel="noopener">https://eel.is/c++draft/dcl.enum#5</a>).</p>
</div>
<div class="paragraph">
<p>So, if your compiler uses signed two&#8217;s complement, you can leave out the underlying type for scoped enums (<a href="https://en.cppreference.com/w/cpp/language/types" class="bare" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/types</a>).</p>
</div>
<div class="paragraph">
<p><strong>But, defining the underlying type for unscoped enumerations is crucial!</strong><br>
(The following Note explains why.)</p>
</div>
<div class="paragraph">
<p>Otherwise the <code>operator ~</code> will invoke UB. Compilers can track this down, e.g. when evaluating constant expressions (cf. <a href="https://eel.is/c++draft/expr.static.cast#10" class="bare" target="_blank" rel="noopener">https://eel.is/c++draft/expr.static.cast#10</a>).<br>
Clang has a warning for it <code>-Wenum-constexpr-conversion</code> and <a href="https://github.com/llvm/llvm-project/issues/59036">they are planing to turn it into a hard error</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>For unscoped enums with unspecified underlying type, the compiler infers two types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the underlying type (<a href="https://eel.is/c++draft/dcl.enum#7" class="bare" target="_blank" rel="noopener">https://eel.is/c++draft/dcl.enum#7</a>), which we can query using <code>std::underlying_type</code></p>
</li>
<li>
<p>a hypothetical integer value type with minimal width such that all enumerators can be represented (<a href="https://eel.is/c++draft/dcl.enum#8" class="bare" target="_blank" rel="noopener">https://eel.is/c++draft/dcl.enum#8</a>)<br>
"The width of the smallest bit-field large enough to hold all the values of the enumeration type [&#8230;&#8203;]."</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This hypothetical integer value type is not deducible from the type of the enumeration. (It requires to know the values of all enumerators.) Furthermore, it is in general not the same as the underlying type. E.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">enum</span> <span class="n">TriBool</span> <span class="p">{</span>
    <span class="n">false_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">true_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">undefined</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>has underlying type <code>int</code> on all major compilers, but its valid values are just
<code>0</code>, <code>1</code>, <code>2</code> and <code>3</code> as the <em>hypothetical integer value type with minimal width</em> is a 2-bit unsigned integer.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="complementing_the_complement">Complementing the <code>complement</code></h3>
<div class="paragraph">
<p>Before going into details, let me tell you a little tale</p>
</div>
<div id="queen_of_hearts_tale" class="exampleblock">
<div class="content">
<div class="paragraph">
<p><span style="font-family:'Times New Roman'">
Once, there was a kingdom, where the Queen of Hearts reigned with iron fist.<br/>She had her own newspaper for proclamations, where they used a set of flags for font-styles</span></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">enum</span> <span class="n">font_styles</span> <span class="o">:</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">bold</span>      <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">italic</span>    <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">underline</span> <span class="o">=</span> <span class="mi">4</span>
<span class="p">};</span>
<span class="c1">// special style for the Queen's proclamations</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">queen_of_hearts_name</span> <span class="o">=</span> <span class="n">italic</span> <span class="o">|</span> <span class="n">underline</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><span style="font-family:'Times New Roman'">
One of the Queen's proclamations had been:<br/>
<span style="font-color:#FFD700; font-size:150%"">All my proclamations shall be encoded in C++, <i><u>the Queen</u></i>!</span>
<br/>And there were loads of them every day. <br/>
A programmer for the newspaper, who was tired of typing <code>queen_of_hearts_name</code> all the time, figured out that typing <code>~bold</code> instead also did the job. This saved him a lot of work. <br/>
One day, the troublemaker Alice came to the kingdom and the Queen ordered the creation of a new font-style</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">strikeout</span> <span class="o">=</span> <span class="mi">8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><span style="font-family:'Times New Roman'">
which should be used for Alice's name. So it got added to the `font_styles` enumeration.<br/>
The next day the following proclamation appeared in the newspaper:<br/>
<span style="font-size:150%">All persons whose names are striken out are enemies of the kingdom, <i><s><u>the Queen</u></s></i>!</span><br/>
The last thing the programmer heard, as he ran away from the kingdom, was the queen shouting "Off with his head!".
</p>
</div>
</div>
</div>
<div class="paragraph">
<p>There are two morals of this tale:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a <strong>syntactical</strong>: the negation flips all bits of the underlying integer. Even though <code>~bold</code> did the job in the beginning, it is different from <code>queen_of_hearts_name</code>.</p>
</li>
<li>
<p>a <strong>semantical</strong>: <code>~bold</code> isn&#8217;t a set of font-modifications. Its purpose is to exclude boldness from a given set of flags.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In a nutshell: the following two operations on sets of flags return another set of flags</p>
</div>
<div class="ulist">
<ul>
<li>
<p>conjunction (<code>operator&amp;</code>): taking the flags that appear in <strong>all</strong> sets</p>
</li>
<li>
<p>disjunction (<code>operator|</code>): taking the flags that appear in <strong>any</strong> of the sets</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>but negation (<code>operator~</code>) in general <strong>does not</strong>.<br>
Sets of flags resemble the semantics of <a href="https://en.wikipedia.org/wiki/Lattice_(order)" target="<em>blank">mathematical lattices</a> rather than the semantics of a <a href="https://en.wikipedia.org/wiki/Boolean_algebra</em>(structure)" target="_blank" rel="noopener">Boolean algebra</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="mathematical_justification_for_complement">Mathematical justification for <code>complement</code></h3>
<div class="paragraph">
<p>This section provides a mathematical explanation, why <code>complement</code> is required. It can easily be <a href="#from_flags_to_bool">skipped</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The underlying type <code>U</code> with the bitwise operations <code>~, &amp;, |</code> and the constants <code>0</code> and <code>-1</code> (all bits set) form a <em>(bitcount of U)</em>-dimensional <a href="https://en.wikipedia.org/wiki/Boolean_algebra_(structure)" target="_blank" rel="noopener">Boolean algebra</a> \((U,0,-1,{\raise.17ex\hbox{$\scriptstyle\sim$}},\&amp;,\mid)\)</p>
</li>
<li>
<p>The defined flags (e.g. <code>bold</code>, <code>italic</code> etc.) with the bitwise operations <code>&amp;, |</code> form a substructure \((F,\&amp;,\mid)\) of \(U\) (cf. <a href="https://en.wikipedia.org/wiki/Lattice_(order)" target="_blank" rel="noopener">mathematical lattices</a>) which in general <strong>is not closed under bitwise negation <code>~</code></strong>.</p>
</li>
<li>
<p>Building the closure \(\overline{F}\) of \(F\) wrt. \({\raise.17ex\hbox{$\scriptstyle\sim$}}\) generates a Boolean algebra which is a Boolean subalgebra of \(U\).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Semantically the elements of \(\overline{F}\setminus F\) are not combinations of flags but negative flag-masks. The distinction of <code>E</code> and <code>complement&lt;E&gt;</code> keeps them apart on the type-level.</p>
</div>
<div class="paragraph">
<p>Finally, for the binary operators we have</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator&amp;</code></p>
<div class="ulist">
<ul>
<li>
<p><code>operator&amp;(E, E) -&gt; E</code></p>
</li>
<li>
<p><code>operator&amp;(complement&lt;E&gt;, E) -&gt; E</code></p>
</li>
<li>
<p><code>operator&amp;(E, complement&lt;E&gt;) -&gt; E</code></p>
</li>
<li>
<p><code>operator&amp;(complement&lt;E&gt;, complement&lt;E&gt;) -&gt; complement&lt;E&gt;</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>operator|</code></p>
<div class="ulist">
<ul>
<li>
<p><code>operator|(E, E) -&gt; E</code></p>
</li>
<li>
<p><code>operator|(complement&lt;E&gt;, E) -&gt; complement&lt;E&gt;</code></p>
</li>
<li>
<p><code>operator|(E, complement&lt;E&gt;) -&gt; complement&lt;E&gt;</code></p>
</li>
<li>
<p><code>operator|(complement&lt;E&gt;, complement&lt;E&gt;) -&gt; complement&lt;E&gt;</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>operator^</code></p>
<div class="ulist">
<ul>
<li>
<p><code>operator^(E, E) -&gt; E</code></p>
</li>
<li>
<p><code>operator^(complement&lt;E&gt;, E) -&gt; complement&lt;E&gt;</code></p>
</li>
<li>
<p><code>operator^(E, complement&lt;E&gt;) -&gt; complement&lt;E&gt;</code></p>
</li>
<li>
<p><code>operator^(complement&lt;E&gt;, complement&lt;E&gt;) -&gt; E</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Which means, on the meta-level the typeset \(\{\textrm{E}, \textrm{complement&lt;E&gt;} \}\) and the operation \({\raise.17ex\hbox{$\scriptstyle\sim$}}\), \(\&amp;\) and \(\mid\) form a two-element Boolean algebra.</p>
</div>
<div class="paragraph">
<p>For the rare case where</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the set of flags semantically forms a Boolean algebra and additionally</p>
</li>
<li>
<p>all bits of the underlying type correspond to flags</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>there exists the option <a href="#boost_flags_disable_complement">boost::flags::options::disable_complement</a> which disables the usage of <code>complement</code> and sets <code>operator~(E) -&gt; E</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="from_flags_to_bool">From flags to <code>bool</code></h3>
<div class="paragraph">
<p>Since scoped enumerations prevent implicit conversion to <code>bool</code>, Boost.Flags provides the following functions (see also <a href="#not_not"><code>operator!</code></a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>any(e) -&gt; bool</code> : equivalent to <code>e != E{}</code></p>
</li>
<li>
<p><code>none(e) -&gt; bool</code> : equivalent to <code>e == E{}</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Furthermore, to test for intersection and entailment of flag-sets:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>intersect(e1, e2) -&gt; bool</code> : equivalent to <code>e1 &amp; e2 != E{}</code></p>
</li>
<li>
<p><code>disjoint(e1, e2) -&gt; bool</code> : equivalent to <code>e1 &amp; e2 == E{}</code></p>
</li>
<li>
<p><code>subseteq(e1, e2) -&gt; bool</code> : equivalent to <code>e1 &amp; e2 == e1</code></p>
</li>
<li>
<p><code>subset(e1, e2) -&gt; bool</code> : equivalent to <code>subseteq(e1, e2) &amp;&amp; e1 != e2</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="not_not"><code>not</code>, <code>not not</code>, why not?</h3>
<div class="paragraph">
<p>Instead of calling <code>any</code> and <code>none</code> we can use <code>operator!</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>!e</code> : equivalent to <code>none(e)</code></p>
</li>
<li>
<p><code>!!e</code> : equivalent to <code>any(e)</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="everything_in_order">Everything in order?</h3>
<div id="overloading_relational_operators" class="paragraph">
<p>Let&#8217;s take a look at the relational operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.</p>
</div>
<div class="paragraph">
<p>For enumerations (scoped and unscoped) C++ provides built-in relational operators which apply the operator to the values of the underlying type.
This order we usually want to use as <em>Compare</em> predicate for sorted containers and sorting algorithms.</p>
</div>
<div class="paragraph">
<p>This total order, is a linearization of a partial order which naturally arises, when we abstract away from the underlying type
 (which is what enumerations are usually about). It is the order induced by flag entailment:</p>
</div>
<div class="paragraph text-center">
<p><code>e1 &lt; e2</code>   if and only if   <code>subset(e1, e2) == true</code></p>
</div>
<div class="paragraph">
<p>(<a href="#contained_induced_partial_order">see below</a>)</p>
</div>
<div class="paragraph">
<p>But, if there is more than one flag, then this order is inherently partial and should never be used as <em>Compare</em> predicate for containers or algorithms.</p>
</div>
<div class="paragraph">
<p>As there are applications for two different orders on the same type, the best would be different sets of relational operators, but C++ offers only one such.<br>
One approach would be, deleting all relational operators for flags and forcing the user to call a function / pass a <em>Compare</em> type as predicate.</p>
</div>
<div class="paragraph">
<p>But here comes the next obstacle from the language:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>C++ allows overloading operators when at least one of its arguments is of <code>class</code> or <code>enum</code> type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">enum</span> <span class="n">E</span><span class="p">{};</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">E</span><span class="p">,</span><span class="n">E</span><span class="p">){</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">test</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">E</span><span class="p">{}</span> <span class="o">&lt;</span> <span class="n">E</span><span class="p">{};</span>       <span class="c1">// calls our operator&lt; and returns true</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This also works for operator templates, but there is one exception:<br>
When an operator template for a relational operator is invoked with the same enumeration type for both arguments, then the built-in operator is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">enum</span> <span class="n">E</span><span class="p">{};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T2</span><span class="p">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span><span class="n">T2</span><span class="p">){</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">test</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">E</span><span class="p">{}</span> <span class="o">&lt;</span> <span class="n">E</span><span class="p">{};</span>       <span class="c1">// calls built-in &lt; and returns false</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There is a Defect Report pending
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2730" class="bare" target="_blank" rel="noopener">https://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2730</a>
 which would make the latter also call the user defined operator template.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Currently, we simply cannot overload relational operators for Boost.Flags enabled enumerations with a function template -
it requires the definition of a function. Thus Boost.Flags provides the following macros</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BOOST_FLAGS_REL_OPS_DELETE(E)</code>: deletes all relational operators for enumeration <code>E</code></p>
</li>
<li>
<p><code>BOOST_FLAGS_REL_OPS_PARTIAL_ORDER(E)</code>: defines all relational operators to reflect the partial order induced by <code>subseteq</code> (<a href="#contained_induced_partial_order">see below</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, there exist the following <em>Compare</em> structs and objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>totally ordered: <code>struct boost::flags::total_order_t</code> and object <code>boost::flags::total_order</code></p>
</li>
<li>
<p>partially ordered: <code>struct boost::flags::partial_order_t</code> and object <code>boost::flags::partial_order</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As C++ allows to specialize <code>std::less</code> for user-defined types, we can provide a macro</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BOOST_FLAGS_SPECIALIZE_STD_LESS(E)</code>: specializes <code>std::less</code> to use <code>boost::flags::total_order</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>which ensures always total ordering for <code>std::less</code> based compare in containers and algorithms.</p>
</div>
<div class="paragraph">
<p>But for range-algorithms the language strikes back again: range compare uses
<code>std::ranges::less</code> which is a struct and thus cannot be specialized. Internally it will do some checks and call <code>operator &lt;</code> if available.<br>
This means, when we define <code>BOOST_FLAGS_REL_OPS_PARTIAL_ORDER(E)</code> then for any range algorithm that compares values of type <code>E</code> we must provide
<code>boost::flags::total_order</code> (or another total ordering) as <em>Compare</em>. Otherwise, we&#8217;re in UB land.</p>
</div>
<div class="paragraph">
<p>So, our recommendation (and the currently most comfortable way without loosing any safety) would be
defining both <code>BOOST_FLAGS_REL_OPS_DELETE(E)</code> and <code>BOOST_FLAGS_SPECIALIZE_STD_LESS(E)</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div id="contained_induced_partial_order" class="paragraph">
<p>For the mathematically inclined programmer:<br>
The function <code>subseteq</code> reflects the partial order (in the mathematical sense) \(\leq\) of the generated Boolean algebra.
You can enable relational operators using the <code>BOOST_FLAGS_REL_OPS_PARTIAL_ORDER</code> macro at global namespace.<br>
<code>BOOST_FLAGS_REL_OPS_PARTIAL_ORDER(E)</code> defines the following semantics for the relational operators</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>e1 &lt;= e2</code> : equivalent to <code>subseteq(e1, e2)</code></p>
</li>
<li>
<p><code>e1 &gt;= e2</code> : equivalent to <code>subseteq(e2, e1)</code></p>
</li>
<li>
<p><code>e1 &lt; e2</code> : equivalent to <code>subset(e1, e2)</code></p>
</li>
<li>
<p><code>e1 &gt; e2</code> : equivalent to <code>subset(e2, e1)</code></p>
</li>
<li>
<p><code>e1 &lt;=&gt; e2</code> : has type <code>std::partial_ordering</code> and is equivalent to</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span>
    <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">partial_ordering</span><span class="o">::</span><span class="n">equivalent</span>
    <span class="o">:</span> <span class="n">subseteq</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
    <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">partial_ordering</span><span class="o">::</span><span class="n">less</span>
    <span class="o">:</span> <span class="n">subseteq</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span>
    <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">partial_ordering</span><span class="o">::</span><span class="n">greater</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">partial_ordering</span><span class="o">::</span><span class="n">unordered</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="flags_and_flags">Flags <code>and</code> Flags</h3>
<div class="paragraph">
<p>Instead of <code>disjoint</code> and <code>intersect</code> we can write:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>!(e1 &amp; e2)</code> : equivalent to <code>disjoint(e1, e2)</code></p>
</li>
<li>
<p><code>!!(e1 &amp; e2)</code> : equivalent to <code>intersect(e1, e2)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If we update existing code with Boost.Flags, then expressions like <code>e1 &amp; e2</code> in boolean contexts would have to be replaced by <code>!!(e1 &amp; e2)</code>. This is tedious and requires adding parenthesis.<br>
Therefore, Boost.Flags provides a pseudo operator <code>BOOST_FLAGS_AND</code> with the same precedence and associativity as <code>&amp;</code> but returning a <code>bool</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>e1 BOOST_FLAGS_AND e2</code> : equivalent to <code>!!(e1 &amp; e2)</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Alternatively, there is the options <a href="#boost_flags_logical_and"><code>boost::flags::options::logical_and</code></a>, which enables <code>operator&amp;&amp;</code>, see <a href="#logically_and_and_or">next section</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p><code>BOOST_FLAGS_AND</code> is a macro defined as <code>&amp; boost::flags::impl::pseudo_and_op_tag{} &amp;</code>.<br>
The first <code>&amp;</code> stores its left-hand argument in an intermediate type, which the second <code>&amp;</code> evaluates with its right-hand argument.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="logically_and_and_or">Logically <code>and</code> and <code>or</code></h3>
<div class="paragraph">
<p>The logical <code>operator &amp;&amp;</code> and <code>operator ||</code> have to handled with care, as they are the only ones to support short-circuit evaluation for the built-in versions.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s first take a look at the semantics of the built-in <code>operator &amp;&amp;</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it converts its first arguments to <code>bool</code>, if its <code>false</code> then returns <code>false</code> (short-circuit evaluation)</p>
</li>
<li>
<p>otherwise converts the second arguments to <code>bool</code> and returns it</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is quite different from the semantics of the built-in bitwise <code>&amp;</code> operator in a boolean context:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it performs intergral promotion on both arguments and compute their bitwise AND</p>
</li>
<li>
<p>returns <code>false</code> if the outcome is equal to <code>0</code> otherwise <code>true</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>E.g. in boolean contexts <code>(1 &amp;&amp; 2)</code> evaluates to <code>true</code>, while <code>(1 &amp; 2)</code> evaluates to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Though, for <code>operator ||</code> and <code>operator |</code> and values <code>v1</code> and <code>v2</code>, in boolean contexts <code>(v1 || v2)</code> and <code>(v1 | v2)</code> always evaluate to the same value, there is still the difference, that <code>operator ||</code> uses short-circuit evaluation and <code>operator |</code> does not.</p>
</div>
<div class="paragraph">
<p>Furthermore, <code>operator &amp;&amp;</code> and <code>operator ||</code> have lower precedences than <code>operator &amp;</code> and <code>operator |</code> (cf. <a href="https://en.cppreference.com/w/cpp/language/operator_precedence" target="_blank" rel="noopener">C++ Operator Precedence</a>), which is another source for errors.</p>
</div>
<div class="paragraph">
<p>Since logical operators <code>&amp;&amp;</code> and <code>||</code> can easily get confused with their bitwise counterparts <code>&amp;</code> and <code>|</code>, by default Boost.Flags disables <code>operator&amp;&amp;</code> and  <code>operator||</code>, when both arguments are implicitly convertible to integral types, to prevent accidentally calling the built-in versions.</p>
</div>
<div class="paragraph">
<p>Nevertheless, sometimes <code>operator &amp;&amp;</code> comes in handy or is even required, e.g. when Boost.Flags is used together with other generic libraries. When for an enabled enumeration <code>E</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">constexpr</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">options</span> <span class="nf">boost_flags_enable</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">options</span><span class="o">::</span><span class="n">enable</span>
         <span class="o">|</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">options</span><span class="o">::</span><span class="n">logical_and</span>
         <span class="p">;</span>
<span class="p">}</span>
<span class="c1">// instead of</span>
<span class="c1">// constexpr bool boost_flags_enable(E){ return true; }</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>is defined or <code>boost::flags::enable&lt;E&gt;</code> inherits from <code>boost::flags::logical_and</code>, then <code>operator &amp;&amp;</code> is overloaded for <code>E</code> with the semantics</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="k">operator</span><span class="o">&amp;&amp;</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">e1</span> <span class="o">&amp;</span> <span class="n">e2</span><span class="p">);</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And once more, there is no short-circuit evaluation!</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>When applying Boost.Flags to existing code, please be cautious enabling <code>operator&amp;&amp;</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p>it evaluates differently than the built-in version and doesn&#8217;t provide short-circuit evaluation</p>
</li>
<li>
<p>the usage of <code>operator&amp;&amp;</code> may have been wrong and <code>operator&amp;</code> was intended</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, before enabling <code>operator&amp;&amp;</code>, it is best to compile the code without it and check whether the uses of <code>operator&amp;&amp;</code> are correct.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>To achieve short-circuit evaluation for expresions with flags, convert the flag-value arguments to <code>bool</code> by using e.g. <code>!!(&#8230;&#8203;) &amp;&amp; !!(&#8230;&#8203;)</code> or <code>any(&#8230;&#8203;) &amp;&amp; any(&#8230;&#8203;)</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="utilities">Utilities</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="functions">Functions</h3>
<div class="paragraph">
<p>Boost.Flags provides the following functions for an enabled enumeration <code>E</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>make_null(E) -&gt; E { return E{}; }</code></p>
</li>
<li>
<p><code>make_if(E e, bool set) -&gt; E { return set ? e : E{}; }</code></p>
</li>
<li>
<p><code>modify(E e, E mod, bool set)  -&gt; E { return set ? e | mod : e &amp; ~mod; }</code></p>
</li>
<li>
<p><code>modify_inplace(E&amp; e, E mod, bool set)  -&gt; E&amp; { e = modify(e, mod, set); return e; }</code></p>
</li>
<li>
<p><code>add_if(E e, E mod, bool add)  -&gt; E { return add ? e | mod : e; }</code></p>
</li>
<li>
<p><code>add_if_inplace(E&amp; e, E mod, bool add)  -&gt; E&amp; { e = add_if(e, mod, add); return e; }</code></p>
</li>
<li>
<p><code>remove_if(E e, E mod, bool remove)  -&gt; E { return remove ? e &amp; ~mod : e; }</code></p>
</li>
<li>
<p><code>remove_if_inplace(E&amp; e, E mod, bool remove)  -&gt; E&amp; { e = remove_if(e, mod, remove); return e; }</code></p>
</li>
<li>
<p><code>get_underlying(E e) -&gt; typename underlying_type&lt;E&gt;::type { return static_cast&lt;typename underlying_type&lt;E&gt;::type&gt;(e); }</code></p>
</li>
<li>
<p><code>from_underlying(typename underlying_type&lt;E&gt;::type u) -&gt; E { return static_cast&lt;E&gt;(u); }</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and for generating the values of enumerators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>template&lt;typename T = int&gt; nth_bit(unsigned int n) -&gt; underlying_or_identity&lt;T&gt;::type { return static_cast&lt;underlying_or_identity&lt;T&gt;::type&gt;(1) &lt;&lt; n; }</code><br>
where type <code>T</code> can be either an enumeration or an integral type, and <code>underlying_or_identity</code> is a type-trait returning the underlying type of the enumeration or is the type-identity respectively</p>
</li>
<li>
<p><code>template&lt;typename T&gt; next_bit(T v) -&gt; T { return v &lt;&lt; 1; }</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="flags_generator">Flags generator</h3>
<div class="paragraph">
<p>Boost.Flags provides a <code>flag_generator</code> class template to iterate over the bits of a flag-enum. The class template is usually not create directly but through a call the one of the following functions</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// generates from first to last (incl.)</span>
    <span class="k">constexpr</span> <span class="n">flag_generator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">flags_from_to</span><span class="p">(</span><span class="n">E</span> <span class="n">first</span><span class="p">,</span> <span class="n">E</span> <span class="n">last</span><span class="p">);</span>

    <span class="c1">// generates from E(1) to last (incl.)</span>
    <span class="k">constexpr</span> <span class="n">flag_generator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">flags_to</span><span class="p">(</span><span class="n">E</span> <span class="n">last</span><span class="p">);</span>

    <span class="c1">// generates all bits of the underlying type of E, starting from E(1)</span>
    <span class="k">constexpr</span> <span class="n">flag_generator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">flags_all</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="c1">// using enum pizza_toppings from example above</span>
<span class="k">auto</span> <span class="n">base_toppings</span> <span class="o">=</span> <span class="n">pizza_toppings</span><span class="o">::</span><span class="n">tomato</span> <span class="o">|</span> <span class="n">pizza_toppings</span><span class="o">::</span><span class="n">cheese</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">f</span> <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">bits_to</span><span class="p">(</span><span class="n">pizza_toppings</span><span class="o">::</span><span class="n">garlic</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">f</span> <span class="o">&amp;</span> <span class="n">base_toppings</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get_underlying</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>template&lt;typename E&gt; flag_generator</code> provides an internal iterator and member functions <code>begin()</code> and <code>end()</code> returning the resp. iterators.<br>
It is contructed with the lowest and highest flag that shall be iterated over.
If <code>flag_generator</code> is constructor with flags not having exactly one bit set, then the behaviour is undefined.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="other_implementations">Other flags-like enum implementations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are several articles and libraries on flag-like enums available. The following is not exhaustive list found on the web in January 2024:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://www.sandordargo.com/blog/2022/06/22/bitwise-enums" class="bare" target="_blank" rel="noopener">https://www.sandordargo.com/blog/2022/06/22/bitwise-enums</a> (SD)</p>
</li>
<li>
<p><a href="https://grisumbras.github.io/enum-flags/" class="bare" target="_blank" rel="noopener">https://grisumbras.github.io/enum-flags/</a> (GR)</p>
</li>
<li>
<p><a href="https://m-peko.github.io/craft-cpp/posts/different-ways-to-define-binary-flags/" class="bare" target="_blank" rel="noopener">https://m-peko.github.io/craft-cpp/posts/different-ways-to-define-binary-flags/</a> (MP)</p>
</li>
<li>
<p><a href="https://doc.qt.io/qt-6/qflags.html" class="bare" target="_blank" rel="noopener">https://doc.qt.io/qt-6/qflags.html</a> (Qt)</p>
</li>
<li>
<p><a href="https://github.com/foonathan/type_safe" class="bare" target="_blank" rel="noopener">https://github.com/foonathan/type_safe</a> (JM)</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms229062(v=vs.100)" class="bare" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms229062(v=vs.100)</a> (.net, language built-in flags support - not usable with ISO-C++ !)</p>
</li>
</ol>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 30%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
<col style="width: 10%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-center valign-top">Boost.Flags</th>
<th class="tableblock halign-center valign-top">SD</th>
<th class="tableblock halign-center valign-top">GR</th>
<th class="tableblock halign-center valign-top">MP</th>
<th class="tableblock halign-center valign-top">Qt</th>
<th class="tableblock halign-center valign-top">JM</th>
<th class="tableblock halign-center valign-top">.net</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">non-intrusive</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">zero-overhead</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">distinguishes complement</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">operators as free functions</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">implementation available</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>-</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>+</strong></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="design_rationale">Design rationale</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The design of Boost.Flags was driven by the following principles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>type-safety</p>
<div class="ulist">
<ul>
<li>
<p>the library shall enforce that binary operators can only be applied to flags or their complements from the same enumeration</p>
</li>
<li>
<p>flag values must be distinguished from their complements on the type-level</p>
</li>
</ul>
</div>
</li>
<li>
<p>non-intrusive</p>
<div class="ulist">
<ul>
<li>
<p>as few as possible changes to the definition of existing flag-like enumeration shall be required</p>
</li>
<li>
<p>no new types for flags, except <code>complement</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>opt-in shall be done by</p>
<div class="ulist">
<ul>
<li>
<p>function overload or</p>
</li>
<li>
<p>template specialization</p>
</li>
</ul>
</div>
</li>
<li>
<p>zero-overhead</p>
<div class="ulist">
<ul>
<li>
<p>for optimized builds operator-calls must produce the same assembly code as built-in calls on the underlying integers</p>
</li>
</ul>
</div>
</li>
<li>
<p>no change of semantics for existing code</p>
<div class="ulist">
<ul>
<li>
<p>enabling Boost.Flags for an existing flag-like enumeration must not produce valid code with different semantics</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first four principles are met by the library. The last principle of course has a notable exception:
 For a given enumeration <code>E</code> values of type <code>complement&lt;E&gt;</code> may invoke different overloads than values of <code>E</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference">Reference</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The contents of the library are in namespace boost::flags.</p>
</div>
<div class="paragraph">
<p>All operators and functions in this library</p>
</div>
<div class="ulist">
<ul>
<li>
<p>are <code>constexpr</code> and <code>noexcept</code></p>
</li>
<li>
<p>use attribute <code>[[nodiscard]]</code> except for assignment operators <code>&amp;=</code>, <code>|=</code>, <code>^=</code> and functions <code>modify_inplace</code>, <code>add_inplace</code>, <code>remove_inplace</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most of the function signatures for operators are written with trailing return type but the leading <code>auto</code> is left out for readability.</p>
</div>
<div class="sect2">
<h3 id="supported_language_versions">Supported language versions</h3>
<div class="paragraph">
<p>Boost.Flags requires at least C++11.</p>
</div>
<div class="paragraph">
<p>Concepts are used if available and not disabled using <a href="#boost_flags_has_concepts"><code>BOOST_FLAGS_HAS_CONCEPTS</code></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="opt_in_2">Opt-in</h3>
<div class="sect3">
<h4 id="boost_flags_enable">boost_flags_enable</h4>
<div class="paragraph">
<p>The function <code>boost_flags_enable</code> can be overloaded for an enumeration <code>E</code> either</p>
</div>
<div class="ulist">
<ul>
<li>
<p>with return-type <code>bool</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">boost_flags_enable</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>enables Boost.Flags for an enumeration <code>E</code>. All optional features are disabled.</p>
</div>
</li>
<li>
<p>or with return-type <code>boost::flags::options</code>:
The flag-enumeration <code>boost::flags::options</code> has the options</p>
<div class="ulist">
<ul>
<li>
<p><code>enable</code>:  enables <code>E</code></p>
</li>
<li>
<p><code>disable_complement</code>:  disables the usage of the <code>complement&lt;E&gt;</code> (see also <a href="#disable_complement"><code>disable_complement</code></a>)</p>
</li>
<li>
<p><code>logical_and</code>:  enables <code>operator&amp;&amp;</code> for <code>E</code> (see also <a href="#logical_and"><code>logical_and</code></a>)
e.g.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">constexpr</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">options</span> <span class="nf">boost_flags_enable</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">options</span><span class="o">::</span><span class="n">enable</span>			<span class="c1">// enable E (required)</span>
        <span class="o">|</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">options</span><span class="o">::</span><span class="n">disable_complement</span> <span class="c1">// disable the usage of the complement</span>
        <span class="o">|</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">options</span><span class="o">::</span><span class="n">logical_and</span>        <span class="c1">// enable operator&amp;&amp;</span>
        <span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The function <code>boost_flags_enable</code> is looked up using <a href="https://en.cppreference.com/w/cpp/language/adl" target="_blank" rel="noopener">ADL</a>.</p>
</div>
<div class="paragraph">
<p>In case <code>E</code> is defined inside a class, a <code>friend</code> function can be used for enabling. E.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">class</span> <span class="nc">my_class</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">enum</span> <span class="k">class</span> <span class="nc">E</span><span class="o">:</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
    <span class="k">friend</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">boost_flags_enable</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A Boost.Flags enabled (scoped/unscoped) enumeration will also be called <em>(scoped/unscoped) flags</em>.</p>
</div>
<div class="paragraph">
<p>Alternatively to using <code>boost_flags_enable</code>, the class template <a href="#types_enable
"><code>boost::flags::enable</code></a> can be specialized.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="types">Types</h3>
<div class="sect3">
<h4 id="enablet">enable&lt;T&gt;</h4>
<div id="types_enable" class="paragraph">
<p>To enable the Boost.Flags functionality specialize the template for an enumeration</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">enable</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>and inherit from <code>std::true_type</code>.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">enum</span> <span class="k">class</span> <span class="nc">my_flags</span> <span class="o">:</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="n">option_a</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
    <span class="n">option_b</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">enable</span><span class="o">&lt;</span><span class="n">my_flags</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A Boost.Flags enabled (scoped/unscoped) enumeration will also be called <em>(scoped/unscoped) flags</em>.</p>
</div>
<div class="paragraph">
<p>When <code>boost::flags::enable</code> is specialized for <code>E</code> any definition of <code>boost_flags_enable</code> or <code>boost_flags_disable_complement</code> for <code>E</code> are ignored
(cf. <a href="#boost_flags_enable"><code>boost_flags_enable</code></a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="complementt">complement&lt;T&gt;</h4>
<div class="paragraph">
<p>To template <code>complement</code> indicates that a value is the bitwise negation of a flag-value.
It is used to distinguish flag-values from <em>negative masks</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">complement</span><span class="p">;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>By default the usage of <code>complement</code> is enabled but can be disabled using <a href="#disable_complement"><code>disable_complement</code></a>.</p>
</div>
<div class="paragraph">
<p>Boost.Flags operators and functions will always strip double `complement`s from flags.</p>
</div>
</div>
<div class="sect3">
<h4 id="disable_complement">disable_complement</h4>
<div class="paragraph">
<p>If the specialization of <code>enable</code> additionally inherits from <code>disable_complement</code> then the usage of the <code>complement</code> template (cf. <a href="#negation_operation"><code>operator~</code></a>) is disabled.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">enable</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
    <span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">disable_complement</span>
    <span class="p">{};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(See also <a href="#boost_flags_enable"><code>boost_flags_enable</code></a>.)</p>
</div>
</div>
<div class="sect3">
<h4 id="logical_and">logical_and</h4>
<div class="paragraph">
<p>If the specialization of <code>enable</code> additionally inherits from <code>logical_and</code> then <code>operator&amp;&amp;</code> is enabled.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">enable</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span>
    <span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">logical_and</span>
    <span class="p">{};</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>(See also <a href="#boost_flags_enable"><code>boost_flags_enable</code></a>.)</p>
</div>
</div>
<div class="sect3">
<h4 id="total_order_t">total_order_t</h4>
<div class="paragraph">
<p>The type <code>boost::flags::total_order_t</code> defines a call-operator which accepts two compatible flag-arguments and compares their underlying values.
(cf. <a href="#boost_flags_specialize_std_less">BOOST_FLAGS_SPECIALIZE_STD_LESS</a>).</p>
</div>
<div class="paragraph">
<p>There is also a functions object</p>
</div>
<div class="paragraph">
<p><code>static constexpr boost::flags::total_order_t total_order;</code></p>
</div>
</div>
<div class="sect3">
<h4 id="partial_order_t">partial_order_t</h4>
<div class="paragraph">
<p>The type <code>boost::flags::partial_order_t</code> defines a call-operator which accepts two compatible flag-arguments and compares them based on flag entailment.
(cf. <a href="#boost_flags_rel_ops_partial_order">BOOST_FLAGS_REL_OPS_PARTIAL_ORDER</a>).</p>
</div>
<div class="paragraph">
<p>There is also a functions object</p>
</div>
<div class="paragraph">
<p><code>static constexpr boost::flags::partial_order_t partial_order;</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="operators">Operators</h3>
<div class="sect3">
<h4 id="negation_operation">operator~</h4>
<div class="paragraph">
<p>Reverses all bits of the underlying integer representation of its argument.</p>
</div>
<div class="paragraph">
<p>The signature of <code>operator~</code> depends on whether <code>complement</code> is enabled (cf. <a href="#disable_complement">disable_complement</a>).</p>
</div>
<div class="paragraph">
<p>When <code>complement</code> is enabled for flags <code>E</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator~(E) -&gt; complement&lt;E&gt;</code></p>
</li>
<li>
<p><code>operator~(complement&lt;E&gt;) -&gt; E</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>otherwise</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator~(E) -&gt; E</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>(cf. <a href="#boost_flags_disable_complement"><code>boost_flags_disable_complement</code></a>)</p>
</div>
</div>
<div class="sect3">
<h4 id="operator">operator&amp;</h4>
<div class="paragraph">
<p>Applies a bitwise AND operation on the underlying integer representations of its arguments.</p>
</div>
<div class="paragraph">
<p>The signature of <code>operator&amp;</code> depends on whether <code>complement</code> is enabled (cf. <a href="#disable_complement">disable_complement</a>).</p>
</div>
<div class="paragraph">
<p>When <code>complement</code> is enabled for flags <code>E</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator&amp;(E, E) -&gt; E</code></p>
</li>
<li>
<p><code>operator&amp;(complement&lt;E&gt;, E) -&gt; E</code></p>
</li>
<li>
<p><code>operator&amp;(E, complement&lt;E&gt;) -&gt; E</code></p>
</li>
<li>
<p><code>operator&amp;(complement&lt;E&gt;, complement&lt;E&gt;) -&gt; complement&lt;E&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>otherwise</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator&amp;(E, E) -&gt; E</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All other <code>operator&amp;</code> where at least one of the arguments is enabled and both are implicitly convertible to an integer type are deleted.</p>
</div>
</div>
<div class="sect3">
<h4 id="operator_2">operator|</h4>
<div class="paragraph">
<p>Applies a bitwise AND operation on the underlying integer representations of its arguments.</p>
</div>
<div class="paragraph">
<p>The signature of <code>operator|</code> depends on whether <code>complement</code> is enabled (cf. <a href="#disable_complement">disable_complement</a>).</p>
</div>
<div class="paragraph">
<p>When <code>complement</code> is enabled for flags <code>E</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator|(E, E) -&gt; E</code></p>
</li>
<li>
<p><code>operator|(complement&lt;E&gt;, E) -&gt; complement&lt;E&gt;</code></p>
</li>
<li>
<p><code>operator|(E, complement&lt;E&gt;) -&gt; complement&lt;E&gt;</code></p>
</li>
<li>
<p><code>operator|(complement&lt;E&gt;, complement&lt;E&gt;) -&gt; complement&lt;E&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>otherwise</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator|(E, E) -&gt; E</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All other <code>operator|</code> where at least one of the arguments is enabled and both are implicitly convertible to an integer type are deleted.</p>
</div>
</div>
<div class="sect3">
<h4 id="operator_3">operator^</h4>
<div class="paragraph">
<p>Applies a bitwise XOR operation on the underlying integer representations of its arguments.</p>
</div>
<div class="paragraph">
<p>The signature of <code>operator^</code> depends on whether <code>complement</code> is enabled (cf. <a href="#disable_complement">disable_complement</a>).</p>
</div>
<div class="paragraph">
<p>When <code>complement</code> is enabled for flags <code>E</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator^(E, E) -&gt; E</code></p>
</li>
<li>
<p><code>operator^(complement&lt;E&gt;, E) -&gt; complement&lt;E&gt;</code></p>
</li>
<li>
<p><code>operator^(E, complement&lt;E&gt;) -&gt; complement&lt;E&gt;</code></p>
</li>
<li>
<p><code>operator^(complement&lt;E&gt;, complement&lt;E&gt;) -&gt; E</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>otherwise</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator^(E, E) -&gt; E</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All other <code>operator^</code> where at least one of the arguments is enabled and both are implicitly convertible to an integer type are deleted.</p>
</div>
</div>
<div class="sect3">
<h4 id="operator_4">operator&amp;=</h4>
<div class="paragraph">
<p>Performs a bitwise AND assignment on the underlying integer representations of its arguments.</p>
</div>
<div class="paragraph">
<p>The signature of <code>operator&amp;=</code> depends on whether <code>complement</code> is enabled (cf. <a href="#disable_complement">disable_complement</a>).</p>
</div>
<div class="paragraph">
<p>When <code>complement</code> is enabled for flags <code>E</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator&amp;=(E&amp;, E) -&gt; E&amp;</code></p>
</li>
<li>
<p><code>operator&amp;=(E&amp;, complement&lt;E&gt;) -&gt; E&amp;</code></p>
</li>
<li>
<p><code>operator&amp;=(complement&lt;E&gt;&amp;, complement&lt;E&gt;) -&gt; complement&lt;E&gt;&amp;</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The assignment <code>operator&amp;=(complement&lt;E&gt;&amp;, E)</code> is <strong>not</strong> available, as it would change the type of the first argument.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>otherwise</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator&amp;=(E&amp;, E) -&gt; E&amp;</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="operator_5">operator|=</h4>
<div class="paragraph">
<p>Performs a bitwise OR assignment on the underlying integer representations of its arguments.</p>
</div>
<div class="paragraph">
<p>The signature of <code>operator|=</code> depends on whether <code>complement</code> is enabled (cf. <a href="#disable_complement">disable_complement</a>).</p>
</div>
<div class="paragraph">
<p>When <code>complement</code> is enabled for flags <code>E</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator|=(E&amp;,E) -&gt; E&amp;</code></p>
</li>
<li>
<p><code>operator|=(complement&lt;E&gt;&amp;,E) -&gt; complement&lt;E&gt;&amp;</code></p>
</li>
<li>
<p><code>operator|=(complement&lt;E&gt;&amp;,complement&lt;E&gt;) -&gt; complement&lt;E&gt;&amp;</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The assignment <code>operator|=(E&amp;, complement&lt;E&gt;)</code> is <strong>not</strong> available, as it would change the type of the first argument.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>otherwise</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator|=(E&amp;,E) -&gt; E&amp;</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="operator_6">operator^=</h4>
<div class="paragraph">
<p>Performs a bitwise XOR assignment on the underlying integer representations of its arguments.</p>
</div>
<div class="paragraph">
<p>The signature of <code>operator^=</code> depends on whether <code>complement</code> is enabled (cf. <a href="#disable_complement">disable_complement</a>).</p>
</div>
<div class="paragraph">
<p>When <code>complement</code> is enabled for flags <code>E</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator^=(E&amp;,E) -&gt; E&amp;</code></p>
</li>
<li>
<p><code>operator^=(complement&lt;E&gt;&amp;,E) -&gt; complement&lt;E&gt;&amp;</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The assignment <code>operator^=(E&amp;, complement&lt;E&gt;)</code> and <code>operator^=(complement&lt;E&gt;&amp;, complement&lt;E&gt;)</code> are <strong>not</strong> available, as they would change the type of the first argument.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>otherwise</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator^=(E&amp;,E) -&gt; E&amp;</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="operator_7">operator!</h4>
<div class="paragraph">
<p>Tests if a value is empty.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!</span><span class="p">(</span><span class="n">E</span> <span class="n">e</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">e</span> <span class="o">==</span> <span class="n">E</span><span class="p">{};</span> <span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pseudo_operator_boost_flags_and">Pseudo operator BOOST_FLAGS_AND</h4>
<div class="paragraph">
<p>Takes the bitwise AND of its arguments and converts the result to <code>bool</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="nf">BOOST_FLAGS_AND</span><span class="p">(</span><span class="n">E</span> <span class="n">e1</span><span class="p">,</span> <span class="n">E</span> <span class="n">e2</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">e1</span> <span class="o">&amp;</span> <span class="n">e2</span><span class="p">);</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>BOOST_FLAGS_AND</code> has same precedence and associativity as <code>operator&amp;</code>. It is a macro defined as<br></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><span class="cp">#define BOOST_FLAGS_AND  &amp; boost::flags::impl::pseudo_and_op_tag{} &amp;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="operator_operator">operator== , operator!=</h3>
<div class="paragraph">
<p>The description is only given for <code>operator==</code>. Calls with reversed arguments and to <code>operator!=</code> will constructed by rewrite rules.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator==(E, E) -&gt; bool</code></p>
</li>
<li>
<p><code>operator==(complement&lt;E&gt;, complement&lt;E&gt;) -&gt; bool</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>equality is defined as usual by applying the operator to the underlying integer.</p>
</div>
<div class="paragraph">
<p>Furthermore the following overloads are defined</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operator==(E, std::nullptr_t) -&gt; bool</code></p>
</li>
<li>
<p><code>operator==(E, impl::null_tag) -&gt; bool</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both test for equality with an underlying value of <code>0</code>. The macro <a href="#boost_flags_null"><code>BOOST_FLAGS_NULL</code></a> defines an instance of <code>impl::null_tag</code>.</p>
</div>
<div class="paragraph">
<p>All other <code>operator==</code> and <code>operator!=</code> where at least one of the arguments is enabled and both are implicitly convertible to an integer type are deleted.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>If <code>E</code> is a scoped enumeration then</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="kt">bool</span> <span class="nf">foo</span><span class="p">(</span><span class="n">E</span> <span class="n">e</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">e</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// literal 0 converts to nullptr, thus</span>
                        <span class="c1">// operator==(E, std::nullptr_t) will be called</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>compiles and returns the expected result.</p>
</div>
<div class="paragraph">
<p>when <code>E</code> is unscoped then above code will fail to compile: the overload <code>operator(E, int)</code> is deleted for unscoped enumerations.<br>
If it wasn&#8217;t then comparison with arbitrary integer values would be possible, as unscoped enumerations implicitly convert to their underlying integer type.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="relational_operators_and">Relational operators &lt;, &lt;=, &gt; and &gt;=</h3>
<div class="paragraph">
<p>The relational operators for enumerations (scoped and unscoped) are provided by the language (by applying the resp. operator to the underlying value).
Furthermore, the current wording doesn&#8217;t allow overloading or deleting those operators by a templated operator (there is a pending Defect Report on this topic:
<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2730" class="bare" target="_blank" rel="noopener">https://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2730</a>).</p>
</div>
<div class="paragraph">
<p>There are macros <a href="#boost_flags_rel_ops_partial_order">BOOST_FLAGS_REL_OPS_PARTIAL_ORDER</a> to overload and <a href="#boost_flags_rel_ops_delete">BOOST_FLAGS_REL_OPS_DELETE</a> to delete relational operators.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>It is recommended to define either <code>BOOST_FLAGS_REL_OPS_DELETE</code> for flag-like enumerations.</p>
</div>
<div class="paragraph">
<p>This prohibits the accidental usage of relational operators with flag values (
The built-in semantics for relational operators compare the underlying numerical values and do not coincide with flag entailment!).</p>
</div>
<div class="paragraph">
<p>When flags have to be stored in ordered container or sorted, please either define <code>BOOST_FLAGS_SPECIALIZE_STD_LESS(E)</code> for the enumeration or specify <code>boost::flags::total_order_t</code> as <em>Compare</em> predicate type.</p>
</div>
<div class="paragraph">
<p>Range algorithms require the specification of <code>boost::flags::total_order</code> as compare object.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="boolean_predicates">Boolean predicates</h3>
<div class="sect3">
<h4 id="any">any</h4>
<div class="paragraph">
<p>Tests if a value is not empty.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">any</span><span class="p">(</span><span class="n">E</span> <span class="n">e</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">E</span><span class="p">{};</span> <span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="none">none</h4>
<div class="paragraph">
<p>Tests if a value is empty.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">none</span><span class="p">(</span><span class="n">E</span> <span class="n">e</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">e</span> <span class="o">==</span> <span class="n">E</span><span class="p">{};</span> <span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="intersect">intersect</h4>
<div class="paragraph">
<p>Tests if two values have common bits set.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">intersect</span><span class="p">(</span><span class="n">E</span> <span class="n">e1</span><span class="p">,</span> <span class="n">E</span> <span class="n">e2</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">e1</span> <span class="o">&amp;</span> <span class="n">e2</span> <span class="o">!=</span> <span class="n">E</span><span class="p">{};</span> <span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="disjoint">disjoint</h4>
<div class="paragraph">
<p>Tests if two values do not have a common bit set.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">disjoint</span><span class="p">(</span><span class="n">E</span> <span class="n">e1</span><span class="p">,</span> <span class="n">E</span> <span class="n">e2</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">e1</span> <span class="o">&amp;</span> <span class="n">e2</span> <span class="o">==</span> <span class="n">E</span><span class="p">{};</span> <span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="subseteq">subseteq</h4>
<div class="paragraph">
<p>Tests if all bits set in the first argument are also set in the second argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">subseteq</span><span class="p">(</span><span class="n">E</span> <span class="n">e1</span><span class="p">,</span> <span class="n">E</span> <span class="n">e2</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">e1</span> <span class="o">&amp;</span> <span class="n">e2</span> <span class="o">==</span> <span class="n">e1</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="subset">subset</h4>
<div class="paragraph">
<p>Tests if the bits set in the first argument are a proper subset of the bits in the second argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">subset</span><span class="p">(</span><span class="n">E</span> <span class="n">e1</span><span class="p">,</span> <span class="n">E</span> <span class="n">e2</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">subseteq</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">e1</span> <span class="o">!=</span> <span class="n">e2</span><span class="p">);</span> <span class="p">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="utility_functions">Utility functions</h3>
<div class="sect3">
<h4 id="make_null">make_null</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">E</span> <span class="n">make_null</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">E</span><span class="p">{};</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For flags <code>E</code> returns an <em>empty</em> instance of type <code>E</code>, i.e. with underlying value of <code>0</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="make_if">make_if</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">E</span> <span class="n">make_if</span><span class="p">(</span><span class="n">E</span> <span class="n">e</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">set</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">set</span> <span class="o">?</span> <span class="n">e</span> <span class="o">:</span> <span class="n">E</span><span class="p">{};</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Depending on <code>set</code> returns either the first argument or empty an instance of type <code>E</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="modify">modify</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">E</span> <span class="n">modify</span><span class="p">(</span><span class="n">E</span> <span class="n">e</span><span class="p">,</span> <span class="n">E</span> <span class="n">mod</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">set</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">set</span> <span class="o">?</span> <span class="n">e</span> <span class="o">|</span> <span class="n">mod</span> <span class="o">:</span> <span class="n">e</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mod</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Depending on <code>set</code> either adds or removes all bits from <code>mod</code> to <code>e</code> and returns the result.</p>
</div>
</div>
<div class="sect3">
<h4 id="modify_inplace">modify_inplace</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="k">constexpr</span> <span class="n">E</span><span class="o">&amp;</span> <span class="n">modify</span><span class="p">(</span><span class="n">E</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="n">E</span> <span class="n">mod</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">set</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">e</span> <span class="o">=</span> <span class="n">modify</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">set</span><span class="p">);</span> <span class="k">return</span> <span class="n">e</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar to <code>modify</code> but applies the modification to <code>e</code> and returns it as reference.</p>
</div>
</div>
<div class="sect3">
<h4 id="add_if">add_if</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">E</span> <span class="n">add_if</span><span class="p">(</span><span class="n">E</span> <span class="n">e</span><span class="p">,</span> <span class="n">E</span> <span class="n">mod</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">add</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">add</span> <span class="o">?</span> <span class="n">e</span> <span class="o">|</span> <span class="n">mod</span> <span class="o">:</span> <span class="n">e</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Depending on <code>add</code> either adds all bits from <code>mod</code> to <code>e</code> or leaves <code>e</code> unmodified and returns the result.</p>
</div>
</div>
<div class="sect3">
<h4 id="add_if_inplace">add_if_inplace</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="k">constexpr</span> <span class="n">E</span><span class="o">&amp;</span> <span class="n">add_if</span><span class="p">(</span><span class="n">E</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="n">E</span> <span class="n">mod</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">add</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">e</span> <span class="o">=</span> <span class="n">add_if</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">add</span><span class="p">);</span> <span class="k">return</span> <span class="n">e</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar to <code>add_if</code> but applies the modification to <code>e</code> and returns it as reference.</p>
</div>
</div>
<div class="sect3">
<h4 id="remove_if">remove_if</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">E</span> <span class="n">remove_if</span><span class="p">(</span><span class="n">E</span> <span class="n">e</span><span class="p">,</span> <span class="n">E</span> <span class="n">mod</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">remove</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">remove</span> <span class="o">?</span> <span class="n">e</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mod</span> <span class="o">:</span> <span class="n">e</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Depending on <code>remove</code> either removes all bits from <code>mod</code> from <code>e</code> or leaves <code>e</code> unmodified and returns the result.</p>
</div>
</div>
<div class="sect3">
<h4 id="remove_if_inplace">remove_if_inplace</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="k">constexpr</span> <span class="n">E</span><span class="o">&amp;</span> <span class="n">remove_if</span><span class="p">(</span><span class="n">E</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">,</span> <span class="n">E</span> <span class="n">mod</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">remove</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">e</span> <span class="o">=</span> <span class="n">remove_if</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">mod</span><span class="p">,</span> <span class="n">remove</span><span class="p">);</span> <span class="k">return</span> <span class="n">e</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar to <code>remove_if</code> but applies the modification to <code>e</code> and returns it as reference.</p>
</div>
</div>
<div class="sect3">
<h4 id="get_underlying">get_underlying</h4>
<div class="paragraph">
<p>Returns the underlying value.<br>
Let <code>U</code> be the underlying type of enabled enum <code>E</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="k">constexpr</span> <span class="n">U</span> <span class="nf">get_underlying</span><span class="p">(</span><span class="n">E</span> <span class="n">e</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="from_underlying">from_underlying</h4>
<div class="paragraph">
<p>Casts an value from underlying value the an enabled enum.<br>
Let <code>U</code> be the underlying type of enabled enum <code>E</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="k">constexpr</span> <span class="n">E</span> <span class="nf">from_underlying</span><span class="p">(</span><span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u</span><span class="p">);</span> <span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nth_bit">nth_bit</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">&gt;</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">underlying_or_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">nth_bit</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">underlying_or_identity</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns a value of type <code>T</code> with the n-th bit from the right set (zero-based) set.
The type <code>T</code> can be either an enumeration or an integral type, and <code>underlying_or_identity</code> is a type-trait returning the underlying type of the enumeration or it is the type-identity respectively.</p>
</div>
</div>
<div class="sect3">
<h4 id="next_bit">next_bit</h4>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="c1">// pseudo code</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">T</span> <span class="nf">next_bit</span><span class="p">(</span><span class="n">T</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Returns to a value <code>v</code> of type <code>T</code> the value with the next higher bit set (if available).<br>
The behaviour is undefined if more than one bit is set in value <code>v</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="flags_generator_2">Flags generator</h3>
<div class="sect3">
<h4 id="flag_generator">flag_generator</h4>
<div class="paragraph">
<p>The <code>template&lt;typename E&gt; flag_generator</code> provides an internal iterator and member functions <code>begin()</code> and <code>end()</code> returning the resp. iterators.<br>
It is contructed with the lowest and highest flag that shall be iterated over.
If <code>flag_generator</code> is constructor with flags not having exactly one bit set, then the behaviour is undefined.</p>
</div>
</div>
<div class="sect3">
<h4 id="flags_from_to">flags_from_to</h4>
<div class="paragraph">
<p>The function</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">E</span><span class="p">&gt;</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">flag_generator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">flags_from_to</span><span class="p">(</span><span class="n">E</span> <span class="n">first</span><span class="p">,</span> <span class="n">E</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>returns a <code>flag_generator</code> instance iterating from <code>first</code> to <code>last</code> (incl.).</p>
</div>
</div>
<div class="sect3">
<h4 id="flags_to">flags_to</h4>
<div class="paragraph">
<p>The function</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">E</span><span class="p">&gt;</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">flag_generator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">flags_to</span><span class="p">(</span><span class="n">E</span> <span class="n">last</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>returns a <code>flag_generator</code> instance iterating from <code>E(1)</code> to <code>last</code> (incl.).</p>
</div>
</div>
<div class="sect3">
<h4 id="flags_all">flags_all</h4>
<div class="paragraph">
<p>The function</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">E</span><span class="p">&gt;</span>
    <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">flag_generator</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">flags_all</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>returns a <code>flag_generator</code> instance iterating from <code>E(1)</code> to the most significant bit of the underlying type of <code>E</code> (incl.), i.e. all bits of the underlying type.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="macros">Macros</h3>
<div class="sect3">
<h4 id="boost_flags_null">BOOST_FLAGS_NULL</h4>
<div class="paragraph">
<p>The macro <code>BOOST_FLAGS_NULL</code> can be used for (in-)equailty testing with a flag-value.</p>
</div>
<div class="paragraph">
<p>For any value <code>e</code> of type flags <code>E</code> the expression <code>e == BOOST_FLAGS_NULL</code> is equivalent to <code>e == E{}</code>. Similarly for  <code>e != BOOST_FLAGS_NULL</code>, <code>BOOST_FLAGS_NULL == e</code> and <code>BOOST_FLAGS_NULL != e</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_rel_ops_delete">BOOST_FLAGS_REL_OPS_DELETE</h4>
<div class="paragraph">
<p>The macro <code>BOOST_FLAGS_REL_OPS_DELETE(E)</code> deletes all relational operators for a Boost.Flags enabled enumeration <code>E</code>.</p>
</div>
<div class="paragraph">
<p>The macro <code>BOOST_FLAGS_REL_OPS_DELETE(E)</code> has to be defined at global namespace.</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_specialize_std_less">BOOST_FLAGS_SPECIALIZE_STD_LESS</h4>
<div class="paragraph">
<p>The macro <code>BOOST_FLAGS_SPECIALIZE_STD_LESS(E)</code> specialize std::less for E and complement&lt;E&gt; with the total order based on the value of the underlying integer type (i.e. <code>&lt;</code> on the underlying integer type).</p>
</div>
<div class="paragraph">
<p>The macro <code>BOOST_FLAGS_SPECIALIZE_STD_LESS(E)</code> has to be defined at global namespace.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>The definition of <code>BOOST_FLAGS_SPECIALIZE_STD_LESS(E)</code> will not enablerange algorithms to use that total order. Here it is required to explicitely specify <code>boost::flags::total_order</code> as compare object.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_rel_ops_partial_order">BOOST_FLAGS_REL_OPS_PARTIAL_ORDER</h4>
<div class="paragraph">
<p>The macro <code>BOOST_FLAGS_REL_OPS_PARTIAL_ORDER(E)</code> defines all relational operators for a Boost.Flags enabled enumeration <code>E</code>.<br>
The following semantics apply</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>e1 &lt;= e2</code> : equivalent to <code>contained(e1, e2)</code></p>
</li>
<li>
<p><code>e1 &gt;= e2</code> : equivalent to <code>contained(e2, e1)</code></p>
</li>
<li>
<p><code>e1 &lt; e2</code> : equivalent to <code>(contained(e1, e2) &amp;&amp; e1 != e2)</code></p>
</li>
<li>
<p><code>e1 &gt; e2</code> : equivalent to <code>(contained(e2, e1) &amp;&amp; e1 != e2)</code></p>
</li>
<li>
<p><code>e1 &lt;=&gt; e2</code> : has type <code>std::partial_ordering</code> and is equivalent to</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp">    <span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span>
    <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">partial_ordering</span><span class="o">::</span><span class="n">equivalent</span>
    <span class="o">:</span> <span class="n">contained</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
    <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">partial_ordering</span><span class="o">::</span><span class="n">less</span>
    <span class="o">:</span> <span class="n">contained</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span>
    <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">partial_ordering</span><span class="o">::</span><span class="n">greater</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">partial_ordering</span><span class="o">::</span><span class="n">unordered</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The macro <code>BOOST_FLAGS_REL_OPS_PARTIAL_ORDER(E)</code> has to be defined at global namespace.</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_specialize_std_less_2">BOOST_FLAGS_SPECIALIZE_STD_LESS</h4>
<div class="paragraph">
<p>The macro <code>BOOST_FLAGS_SPECIALIZE_STD_LESS(E)</code> specializes <code>std::less</code> for <code>E</code> to use <code>boost::flags::total_order</code>.</p>
</div>
<div class="paragraph">
<p>The macro <code>BOOST_FLAGS_SPECIALIZE_STD_LESS(E)</code> has to be defined at global namespace.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuration_macros">Configuration Macros</h3>
<div class="paragraph">
<p>If not specified, all the following macros are deduced from the system, compiler, C++ version.
(Boost.Flags is tested with all major compilers on linux (ubuntu), macos and windows.)</p>
</div>
<div class="sect3">
<h4 id="boost_flags_has_three_way_comparison">BOOST_FLAGS_HAS_THREE_WAY_COMPARISON</h4>
<div class="paragraph">
<p>Specifies, if three way comparison (&#8656;&gt;) is available.</p>
</div>
<div class="paragraph">
<p>Possible values: 0 or 1</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_has_partial_ordering">BOOST_FLAGS_HAS_PARTIAL_ORDERING</h4>
<div class="paragraph">
<p>Specifies, if <code>std::partial_ordering</code> is available.</p>
</div>
<div class="paragraph">
<p>Possible values: 0 or 1</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_has_concepts">BOOST_FLAGS_HAS_CONCEPTS</h4>
<div class="paragraph">
<p>Specifies, if the compiler supports concepts.</p>
</div>
<div class="paragraph">
<p>Possible values: 0 or 1</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_has_is_scoped_enum">BOOST_FLAGS_HAS_IS_SCOPED_ENUM</h4>
<div class="paragraph">
<p>Specifies, if <code>std::is_scoped_enum</code> is available.</p>
</div>
<div class="paragraph">
<p>Possible values: 0 or 1</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_has_logical_traits">BOOST_FLAGS_HAS_LOGICAL_TRAITS</h4>
<div class="paragraph">
<p>Specifies, if the logical traits <code>std::conjunction</code>, <code>std::disjunction</code> and <code>std::negation</code> are available.</p>
</div>
<div class="paragraph">
<p>Possible values: 0 or 1</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_has_inline_variables">BOOST_FLAGS_HAS_INLINE_VARIABLES</h4>
<div class="paragraph">
<p>Specifies, if the <code>inline</code> variables are available (and work correctly: broken in msvc before version v142).</p>
</div>
<div class="paragraph">
<p>Possible values: 0 or 1</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_define_partial_ordering_objects">BOOST_FLAGS_DEFINE_PARTIAL_ORDERING_OBJECTS</h4>
<div class="paragraph">
<p>Specifies, if the partial_ordering emulation is defined.<br>
Only used, when <code>std::partial_ordering</code> is not available.</p>
</div>
<div class="paragraph">
<p>Possible values: 0 or 1</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_has_rewritten_candidates">BOOST_FLAGS_HAS_REWRITTEN_CANDIDATES</h4>
<div class="paragraph">
<p>Specifies, if <a href="https://en.cppreference.com/w/cpp/language/operators" target="_blank" rel="noopener">rewitten candidates</a> are availabe.</p>
</div>
<div class="paragraph">
<p>Possible values: 0 or 1</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_weak_symbol">BOOST_FLAGS_WEAK_SYMBOL</h4>
<div class="paragraph">
<p>Text used to specify a symbol with weak linkage</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>__declspec(selectany)</code> for mscv and clang-cl, ICC on windows</p>
</li>
<li>
<p><code>__attribute__((weak))</code> for g and clang, except for g on mingw: in that case please define <code>BOOST_FLAGS_DEFINE_PARTIAL_ORDERING_OBJECTS=1</code> in exactly one translation unit</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_attribute_nodiscard">BOOST_FLAGS_ATTRIBUTE_NODISCARD</h4>
<div class="paragraph">
<p>Text used as nodiscard attribute (e.g. <code>[[nodiscard]]</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="boost_flags_attribute_nodiscard_ctor">BOOST_FLAGS_ATTRIBUTE_NODISCARD_CTOR</h4>
<div class="paragraph">
<p>Text used as nodiscard attribute for constructors (e.g. <code>[[nodiscard]]</code>).</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copyright_and_license">Appendix A: Copyright and License</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This documentation is</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Copyright 2024 Tobias Loew</p>
</li>
<li>
<p>Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2024-03-15 16:21:45 +0100
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains("stemblock")) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
<style>

*:not(pre)>code { background: none; color: #600000; }
:not(pre):not([class^=L])>code { background: none; color: #600000; }

</style>
</body>
</html>