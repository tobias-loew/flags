////
Copyright 2024, 2025 Tobias Loew
Distributed under the Boost Software License, Version 1.0.
http://www.boost.org/LICENSE_1_0.txt
////

:source-highlighter: rouge
:source-language: cpp

[#description]
# Code hardening with type-safe bitwise operations - TL;DR
:toc:
:toc-title: 
:idprefix:
// :stem: latexmath

## How to use Boost.Flags

* include the header ``<boost/flags.hpp>``
* opt-in for an enumeration `E` by defining
[source]
----
BOOST_FLAGS(E)
----
in the same namespace as `E`.

[#intro_example]
https://godbolt.org/z/PPoKaGrzc[Example, window=_blank] on Godbolt compiler explorer

[source,subs="+quotes,+macros"]
----
#include <boost/flags.hpp>

enum class pizza_toppings {
    tomato       = boost::flags::nth_bit(0), // == 0x01
    cheese       = boost::flags::nth_bit(1), // == 0x02
    salami       = boost::flags::nth_bit(2), // == 0x04
    olives       = boost::flags::nth_bit(3), // == 0x08
    garlic       = boost::flags::nth_bit(4), // == 0x10

    all_toppings = tomato | cheese | salami | olives | garlic,
};
// enable Boost.Flags for pizza_toppings
BOOST_FLAGS(pizza_toppings)

enum class ice_cream_flavours {
    vanilla      = boost::flags::nth_bit(0), // == 0x01
    chocolate    = boost::flags::nth_bit(1), // == 0x02
    strawberry   = boost::flags::nth_bit(2), // == 0x04
};
// enable Boost.Flags for ice_cream_flavours
BOOST_FLAGS(ice_cream_flavours)

// order selected pizza
void order_pizza(pizza_toppings toppings) { 
    std::cout << "Pizza ordered with\n";
    if (boost::flags::any(toppings & pizza_toppings::tomato)) {
        std::cout << "- tomato\n";
    }
    if (boost::flags::any(toppings & pizza_toppings::cheese)) {
        std::cout << "- cheese\n";
    }
    if (boost::flags::any(toppings & pizza_toppings::salami)) {
        std::cout << "- salami\n";
    }
    if (boost::flags::any(toppings & pizza_toppings::olives)) {
        std::cout << "- olives\n";
    }
    if (boost::flags::any(toppings & pizza_toppings::garlic)) {
        std::cout << "- garlic\n";
    }
    std::cout << "\n";
}

// order selected dessert
void order_ice_cream(ice_cream_flavours flavours) { 
    std::cout << "Ice cream ordered with flavours\n";
    if (boost::flags::any(flavours & ice_cream_flavours::vanilla)) {
        std::cout << "- vanilla\n";
    }
    if (boost::flags::any(flavours & ice_cream_flavours::chocolate)) {
        std::cout << "- chocolate\n";
    }
    if (boost::flags::any(flavours & ice_cream_flavours::strawberry)) {
        std::cout << "- strawberry\n";
    }
    std::cout << "\n";
}

int main() {
    pizza_toppings toppings = pizza_toppings::tomato | pizza_toppings::cheese; // a decent start
    toppings |= pizza_toppings::salami | pizza_toppings::olives;    // even better
    order_pizza(toppings);                              // order main course
    order_pizza(toppings & ~pizza_toppings::salami);    // order a vegetarian pizza
    order_ice_cream(ice_cream_flavours::vanilla);       // order desert

    // Guest: "Pizza without olives!"
    // Waiter: "Ok, no olives. But what else to put on it?"
    // error: negative mask is not a pizza topping
    pass:[<span style="text-decoration: red wavy underline; text-decoration-skip-ink: none;">order_pizza(~pizza_toppings::olives);</span>]

    // Guest: "Pizza with all toppings but olives!"
    // Waiter: "Ok, got it!"
    // Waiter takes note: Pizza with tomato, cheese, salami, garlic.
    order_pizza(pizza_toppings::all_toppings & ~pizza_toppings::olives);

    // error: mixing different enumerations
    pass:[<span style="text-decoration: red wavy underline; text-decoration-skip-ink: none;">toppings |= ice_cream_flavours::strawberry;</span>]

    // error: called with wrong enumeration
    pass:[<span style="text-decoration: red wavy underline; text-decoration-skip-ink: none;">order_ice_cream(toppings);</span>]                          
}
----
// "



## Why use Boost.Flags

* provides type-safe bitwise operations for flag-like scoped / unscoped enumerations
* turns logical errors into type errors

## Characteristics of Boost.Flags

* is non-intrusive - only a macro invocation is required to opt-in
* single header-file library
* no dependencies (only standard-library includes)
* compile-time usable - everything is `constexpr`
* zero-overhead (in optimized builds)
* operators are found by https://en.cppreference.com/w/cpp/language/adl[ADL,window=_blank]
* requires at least C++11, uses newer features if available

## Opt-in

To opt-in to Boost.Flags for an enumeration `E` the easiest and most comfortable way is to use the macro `BOOST_FLAGS` for `E` in the same namespace as `E`
[source]
----
enum class E { ... };
BOOST_FLAGS(E)
----

Best practice would be writing `BOOST_FLAGS(E)` right after its definition / declaration.

In case the enumeration `E` is defined inside a class or class template, the macro `BOOST_FLAGS_LOCAL` has to be used instead:

[source]
----
class my_class {
    // ...
    enum class E { ... };
    BOOST_FLAGS_LOCAL(E)
    // ...
};
----


[NOTE]
====
Inside class definitions, `constexpr` constructions using Boost.Flags enabled operators may fail to compile:
[source,subs="+quotes,+macros"]
----
class my_class {
    // ...
    enum class E { 
        flag_0 = 0x1,
        flag_1 = 0x2,
    };
    BOOST_FLAGS_LOCAL(E)
    
    static constexpr E flag_0_or_flag_1 = pass:[<span style="text-decoration: red wavy underline; text-decoration-skip-ink: none;">E::flag_0 | E::flag_1;</span>]
};
----

The reason is, that `BOOST_FLAGS_LOCAL(E)` generates `friend` operators which are _declared_ in the class but _defined_ is after it, thus they are 
inaccessible for in-class `constexpr` constructions. To work around this limitation, please use the following code:
[source]
----
BOOST_FLAGS_USING_OPERATORS()

class my_class {
    // ...
    enum class E { 
        flag_0 = 0x1,
        flag_1 = 0x2,
    };
    BOOST_FLAGS_LOCAL(E, BOOST_FLAGS_NO_FORWARDING)
    
    static constexpr E flag_0_or_flag_1 = E::flag_0 | E::flag_1;
};
----
====

In case you want to check whether an enumeration is enabled for Boost.Flags, you can test it using `boost::flags::enable` (resp. `boost::flags::enable_v` for C++14 or later), e.g.
[source]
----
static_assert(boost::flags::enable<E>::value, "Please check if boost/flags.hpp is included and E is enabled correctly.");
----



## _Scoped_ or _Unscoped_ enumerations

The usage of scoped enumeration is strongly recommended, as they prohibit implicit conversion to the underlying integer type and thus provide more type safety. Further, by default scoped enumerations do not pollute the current namespace with the names of their enumerators.

Nevertheless, for both kinds of enumerations Boost.Flags will detect semantical errors when using bitwise operations.

For scoped enumerations the language does not provide built-in bitwise and logical operators, so Boost.Flags will provide them as requested.

For unscoped enumerations the language provides built-in bitwise and logical operators. Hence, Boost.Flags will delete binary operators `&`, `|`, `^`, `&&`, `||`, `==` and `!=` if

* at least one of its arguments is enabled for Boost.Flags 

and

* both arguments are implicitly convertible to an integer type 

and

* for enumeration `E` both arguments are not xref:compatible[compatible]


## The underlying type

In most situations the usage of Boost.Flags does not depend on the enumeration's underlying type.
Only when Boost.Flags is used with an *unscoped* enumeration `E` in connection with option `disable_complement` (i.e. `operator~(E) \-> E`) then the specification of the underlying type is required to prevent undefined behavior. For details xref:underlying_type[see below.]

# The long story

Why do we use the bits of integer types for Boolean options?

- easy to define, e.g. as macros, integer constants or enumerators
- language support for setting and querying through bitwise operators
- compact representation in memory
- simple bulk transfer in interfaces (e.g. on many platforms an `unsigned int` can hold up to 32 different Boolean options)
- enforces the usage of names, especially to prevent `bool` parameters in interfaces

C++ has everything built-in to work with boolean flags, so why do we need Boost.Flags? 

Because the language allows to do **too much** with them!

## Type-Safety

For flags based on integer-types or unscoped enumerations all values are implicitly convertible to `int`. The compiler can't help, when we accidentally apply binary operators to unrelated flags. 

Here's an example from the Win32-API: 

In `WinUser.h` we find the listbox-style
[source]
----
#define LBS_NOTIFY            0x0001L
----
and the button-style
[source]
----
#define BS_NOTIFY           0x00004000L
----
If we forget the leading `L` of `LBS_NOTIFY` and write
[source]
----
    if (listbox_styles & BS_NOTIFY) { ... }
----
instead, we produced syntactically correct code but semantical nonsense. 

[discrete]
### Switching to enumerations makes it even worse
If the Windows team had decided to use unscoped enumerations instead of macros it wouldn't have helped: the arguments of built-in bitwise operators are subject to integral promotion, i.e. they forget about the enumeration's semantic overhead. Even worse:


* The built-in operators `&`, `|`, `^` and `~` return integer types. Assigning their results to enumeration-type variables require explicit casts, which is another source for errors undetectable by the compiler.
* The built-in operators `&=`, `|=`, `^=` require the left-hand type to be arithmetic, which excludes enumerations.

Furthermore, scoped enumerations (which didn't exist when `WinUser.h` was created) prohibit implicit integral promotion and therefore don't work with built-in bitwise operators at all.


[discrete]
### But enumerations provide type-safety
On the other hand, enumerations, and especially scoped enumerations, improve the type-safety of our code:

* variables and arguments of enumeration type can only by assigned (resp. invoked) with a values of the correct type
* there is no implicit integral promotion for scoped enumerations

[discrete]
### With Boost.Flags you can get both 
With Boost.Flags we get support for all bitwise operators and type-safety. E.g. the following code
[source]
----
enum class E { a=1, b=2, c=4, d=8 };
BOOST_FLAGS(E)
----

* enables all the operators `~`, `&`, `|`, `^`, `&=`, `|=`, `^=` for `E` and `complement<E>` (xref:complementing_the_complement[see below])
* the bitwise negation `~` changes the type from `E` to `complement<E>` and vice-versa
* the binary operators require both arguments to be from the enumeration resp. its `complement`


[#underlying_type]
## The underlying type

Here is a standard conforming decision diagram, whether the specification of the underlying type required:
[ditaa, target=underlying_type_decision_diagram_conforming]
----
                          /-------------\
                          |    Start    |
                          \------+------/
                                 |
                                 |
                       +---------+---------+
                       |{c}                |
                       |     language      |
          +------------+  standard version +-------+
          |            |   is 20 or later  |       |
          |            |                   |       |
       no |            +-------------------+       | yes
          |                                        |
          |                                        |
          |                                        v
          |                           +------------+------------+
          |                           |{c}       enum           |
          |                           |    type is unscoped     |
          |                       +---+  and disable_complement +---+
          |                       |   |         is used         |   |
          |                       |   |                         |   |
          |                   yes |   +-------------------------+   | no
          |                       |                                 |
          |                       |                                 |
          v                       v                                 v
/---------+---------\   /---------+----------\             /--------+--------\
| underlying type   |   | underlying type    |             | underlying type |
| required, must be |   | required, can be   |             | not required    |
| an unsigned type  |   | signed or unsigned |             |                 |
\-------------------/   \--------------------/             \-----------------/

----

Ok, the `unsigned` requirement for pre C\\++20 compilers is more of a theoretical issue, since all C++ compilers already used two's complement for signed integers, even before it got mandatory with C++20 (https://en.cppreference.com/w/cpp/language/types[, window=_blank]).


So, in case your compiler uses signed two's complement, you can use the following simplified decision diagram:
[ditaa, target=underlying_type_decision_diagram_practical]
----
                       /-------------\
                       |    Start    |
                       \------+------/
                              |
                              |
                              v
                 +------------+------------+
                 |{c}       enum           |
                 |    type is unscoped     |
             +---+  and disable_complement +---+
             |   |         is used         |   |
             |   |                         |   |
         yes |   +-------------------------+   | no
             |                                 |
             |                                 |
             v                                 v
   /---------+----------\             /--------+--------\
   | underlying type    |             | underlying type |
   | required, can be   |             | not required    |
   | signed or unsigned |             |                 |
   \--------------------/             \-----------------/

----




It may seem pedantic, but defining the underlying type in the unscoped and xref:disable_complement[`disable_complement`] case is crucial, as otherwise the `operator~` will invoke undefined behavior, when its result is not within the value range of the enumeration. +
Compilers can track this down, e.g. when evaluating constant expressions (cf. https://eel.is/c++draft/expr.static.cast#8[, window=_blank]). +
Starting with Clang 16 this is diagnosed as a hard error.

[#unscoped_complement]
[NOTE]
====
For unscoped enums with unspecified underlying type, the compiler infers two types:

* the underlying type (https://eel.is/c++draft/dcl.enum#7[,window=_blank]), which can be queried using `std::underlying_type`
* a hypothetical integer value type with minimal width such that all enumerators can be represented (https://eel.is/c++draft/dcl.enum#8[,window=_blank]) +
  "The width of the smallest bit-field large enough to hold all the values of the enumeration type [...]." 
  
//  This type is not deducible from the type of the enumeration. (It requires to know the values of all enumerators.)

The deduction of this hypothetical integer value type requires static reflection which is only available in C++26. (It requires to know the values of all enumerators.) Furthermore, it is in general not the same as the underlying type. E.g.
[source]
----
enum TriBool {
    false_ = 0,
    true_ = 1,
    undefined = 2
};
----
has underlying type `int` on all major compilers, but its valid values are just 
`0`, `1`, `2` and `3` as the __hypothetical integer value type with minimal width__ is a 2-bit unsigned integer.

====


## Complementing the `complement`

Before going into details, here is a little story:

[#queen_of_hearts_tale]
====
+++<span style="font-family:'Times New Roman'">
Once, there was a kingdom, where the Queen of Hearts reigned with iron fist.<br/>She had her own newspaper for proclamations, where they used a set of flags for font-styles</span>+++
[source]
----
enum font_styles : unsigned int {
    bold      = 1,
    italic    = 2,
    underline = 4
};
// special style for the Queen's proclamations
static constexpr auto queen_of_hearts_name = italic | underline;
----
+++<span style="font-family:'Times New Roman'">
One of the Queen's proclamations had been:<br/> 
<span style="font-color:#FFD700; font-size:150%"">All my proclamations shall be encoded in C++, <i><u>the Queen</u></i>!</span> 
<br/>And there were loads of them every day. <br/>
A programmer for the newspaper, who was tired of typing <code>queen_of_hearts_name</code> all the time, figured out that typing <code>~bold</code> instead also did the job. This saved him a lot of work. <br/>
One day, the troublemaker Alice came to the kingdom and the Queen ordered the creation of a new font-style+++
[source]
----
    strikeout = 8
----
+++<span style="font-family:'Times New Roman'">
which should be used for Alice's name. So it got added to the `font_styles` enumeration.<br/>
The next day the following proclamation appeared in the newspaper:<br/>
<span style="font-size:150%">All persons whose names are stricken out are enemies of the kingdom, <i><s><u>the Queen</u></s></i>!</span><br/> 
The last thing the programmer heard, as he ran away from the kingdom, was the queen shouting "Off with his head!".
+++
====
There are two morals of this tale:

* a *syntactical*: the negation flips all bits of the underlying integer. Even though `~bold` did the job in the beginning, it is different from `queen_of_hearts_name`. 
* a *semantical*: `~bold` isn't a set of font-modifications. Its purpose is to exclude boldness from a given set of flags.


Even though the underlying type together with its operators `&`, `|` and `~` denotes a https://en.wikipedia.org/wiki/Boolean_algebra_(structure)[Boolean algebra,window=_blank], when using it as set of flags only the operator `&` and `|` are endo-functions: the operator `~` returns an element from a __complemented__ set. 

So, inside the Boolean algebra of the underlying type, there exist two sets of flags, where each of them resembles the semantics of https://en.wikipedia.org/wiki/Lattice_(order)[mathematical lattices, window=_blank] and both are entangled by the operator `~`. 

Hence, for a Boost.Flags enabled enumeration `E` (where complement is not xref:reference.adoc#disable_complement[disabled]) the bitwise not operator switches between the types `E` and `complement<E>`  

* `operator~(E) \-> complement<E>`
* `operator~(complement<E>) \-> E`

[#compatible]
We will call arguments for binary operators _compatible_ if the Boost.Flags provided operators are viable, i.e. each one is implicitly convertible to `E` or `complement<E>`. Additionally, for `operator==` and `operator!=` both have to be convertible to `E` or both have to be convertible to `complement<E>`. For assignment operators additional requirements apply (cf. xref:Operators[Operators]).

## Mathematical justification for `complement`

This section provides a mathematical explanation, why `complement` is required. It can easily be xref:from_flags_to_bool[skipped].

* The underlying type `U` with the bitwise operations `~, &, |` and the constants `0` and `-1` (all bits set) form a _(bitcount of U)_-dimensional https://en.wikipedia.org/wiki/Boolean_algebra_(structure)[Boolean algebra,window=_blank] pass:[<span style="font-size:115%">(<span style="font-style:italic">U</span>, 0, -1, &sim;, &amp;, &mid;)</span>] 
* The defined flags (usually given by the single-bit enumerators) with the bitwise operations `&, |` form a substructure pass:[<span style="font-size:115%">(<span style="font-style:italic">F</span>, &amp;, &mid;)</span>] of pass:[<span style="font-size:115%;font-style: italic">U</span>] (cf. https://en.wikipedia.org/wiki/Lattice_(order)[mathematical lattices, window=_blank]) which in general *is not closed under bitwise negation `~`*.
* Building the closure pass:[<span style="font-size:115%;font-style: italic"><span style="text-decoration:overline">F</span></span>] of pass:[<span style="font-size:115%;font-style: italic">F</span>] wrt. pass:[<span style="font-size:115%">&sim;</span>] generates a Boolean algebra which is a Boolean subalgebra of pass:[<span style="font-size:115%;font-style: italic">U</span>].

Semantically, the elements of pass:[<span style="font-size:115%;font-style: italic"><span style="text-decoration:overline">F</span>&setminus; F</span>] are not combinations of flags but negative flag-masks. The distinction of `E` and `complement<E>` keeps them apart on the type-level. 

Finally, for the binary operators we have

* `operator&`
** `operator&(E, E) \-> E`
** `operator&(complement<E>, E) \-> E`
** `operator&(E, complement<E>) \-> E`
** `operator&(complement<E>, complement<E>) \-> complement<E>`

* `operator|`
** `operator|(E, E) \-> E`
** `operator|(complement<E>, E) \-> complement<E>`
** `operator|(E, complement<E>) \-> complement<E>`
** `operator|(complement<E>, complement<E>) \-> complement<E>`

* `operator^`
** `operator^(E, E) \-> E`
** `operator^(complement<E>, E) \-> complement<E>`
** `operator^(E, complement<E>) \-> complement<E>`
** `operator^(complement<E>, complement<E>) \-> E`

Which means, on the meta-level the typeset pass:[<span style="font-size:115%">{E, complement&lt;E&gt;}</span>] and the operation pass:[<span style="font-size:115%">&sim;</span>], pass:[<span style="font-size:115%">&amp;</span>] and  pass:[<span style="font-size:115%">&mid; </span>] form a two-element Boolean algebra.

For the rare cases where 

* the set of flags semantically form a Boolean algebra and additionally
* all bits of the underlying type correspond to flags

there exists the option xref:disable_complement[`disable_complement`] which disables the usage of `complement` and sets `operator~(E) \-> E`. 


## From flags to `bool`

One of the recommendations when hardening existing code with Boost.Flags is the use of scoped enumerations, as they do not implicitly convert to their underlying type. But this will also prevent the conversion in boolean contexts. Therefore Boost.Flags provides the following functions:

* `any(e) \-> bool` : equivalent to `e != E{}`
* `none(e) \-> bool` : equivalent to `e == E{}`

Furthermore, to test for intersection and entailment of flag-sets:

* `intersect(e1, e2) \-> bool` : equivalent to `e1 & e2 != E{}`
* `disjoint(e1, e2) \-> bool` : equivalent to `e1 & e2 == E{}`
* `subseteq(e1, e2) \-> bool` : equivalent to `e1 & e2 == e1`
* `subset(e1, e2) \-> bool` : equivalent to `subseteq(e1, e2) && e1 != e2`

Instead of the functions `any` and `none`, we can use `operator!`

* `!e` : equivalent to `none(e)`
* `!!e` : equivalent to `any(e)`

and for `disjoint` and `intersect` we can write:

* `!(e1 & e2)` : equivalent to `disjoint(e1, e2)`
* `!!(e1 & e2)` : equivalent to `intersect(e1, e2)`

If existing code is hardened with Boost.Flags and unscoped enums are made scoped, then expressions like `e1 & e2` in Boolean contexts would have to be replaced by `!!(e1 & e2)`. This is tedious and requires adding parenthesis. +
Therefore, Boost.Flags provides two alternatives:

[#unary_plus_operator]
* the _unary_ plus operator `+e`, which wraps `e` into a type which has an `explicit operator bool()` and promotes the wrapped type through further bitwise operations. +
So, with an previously unscoped enum and the code `e1 & ~(e2 | e3)` in boolean contexts, with Boost.Flags enabled all the following expression yield the same result:

** `+(e1 & ~(e2 | e3))`
** `+e1 & ~(e2 | e3)`
** `e1 & ~(+e2 | e3)`
** `+e1 & ~(+e2 | +e3)`
** `+(+e1 & +(~(+e2 | +e3)))`
** ...

* a pseudo operator `BOOST_FLAGS_AND` with the same precedence and associativity as `&` but returning a `bool`:
** `e1 BOOST_FLAGS_AND e2` : equivalent to `!!(e1 & e2)` 

// +
// There is also the option xref:BOOST_FLAGS[`BOOST_FLAGS_LOGICAL_AND`], which enables `operator&&`, see xref:logical_and_and_or[next section].

[NOTE]
====
`BOOST_FLAGS_AND` is a macro defined as `& boost::flags::pseudo_and_op_tag{} &`. +
The first `&` stores its left-hand argument in an intermediate type, which the second `&` evaluates with its right-hand argument.
====

[#logical_and_and_or]
## Logical `and` and `or`

The logical `operator&&` and `operator||` are special among overloadable operators in C++: their built-in versions use short-circuit evaluation, but overloaded versions behave like regular functions and always evaluate both arguments.

Furthermore, for integer and (non Boost.Flags enabled) unscoped enumeration-typed expressions `a` and `b`, both `(a) & (b)` and `(a) && (b)` (resp. `(a) | (b)` and `(a) || (b)`) are all syntactically valid expressions but with different semantics

* `(a) & (b)` (resp. `(a) | (b)`) always evaluates `b`
* `(a) & (b)` and `(a) && (b)` (resp. `(a) | (b)` and `(a) || (b)`) have different result-types

Even in Boolean contexts `(a) & (b)` and `(a) && (b)` return different results (e.g. for arguments `1` and `2`).

To be on the safe side, Boost.Flags by default deletes `operator&&` and `operator||` for enabled enumerations. When applied to existing code, this will lead to compilation errors and enforces revisiting their uses.

Nevertheless, sometimes `operator&&` comes in handy or is even required, e.g. when Boost.Flags is used together with other generic libraries. If for an enumeration `E`
[source]
----
BOOST_FLAGS(E, BOOST_FLAGS_LOGICAL_AND)

// resp. for a class local enum
BOOST_FLAGS_LOCAL(E, BOOST_FLAGS_LOGICAL_AND)
----
is defined, then `operator&&` is overloaded for `E` with the semantics
[source]
----
    operator&&(e1, e2) -> bool { return !!(e1 & e2); } 
----
and there is **no short-circuit** evaluation!

[WARNING]
====
When applying Boost.Flags to existing code, please be cautious enabling `operator&&` 

* it evaluates differently than the built-in version and doesn't provide short-circuit evaluation
* the usage of `operator&&` may have been wrong and `operator&` was intended

So, before enabling `operator&&`, it is best to compile the code without it and check whether the uses of `operator&&` are correct.
====

[NOTE]
====
To achieve short-circuit evaluation for expressions with flags, first convert the flag-value arguments to `bool` by using e.g. `!!(...) && !!(...)` or `any(...) && any(...)`.
====


## Calls to order
[#overloading_relational_operators]
Let's take a look at the relational operators `<`, `\<=`, `>`, `>=` and `\<\=>`.

For integer-based types, including scoped and unscoped enumerations, C++ provides built-in relational operators which apply the operator to the values (of the underlying type in case of enumerations). The induced order is a total: for any two values exactly one of the operators `<`, `==`, `>` evaluates to `true`.
These total orders are **syntactically** important, as we normally use them as _Compare_ predicate for sorted containers and sorting algorithms.

But **semantically**, these orders do not carry much information: for the (xref:intro_example[introducing example]), the meaning of

[.text-center]
`pizza_toppings::cheese | pizza_toppings::salami < pizza_toppings::olives`

reduces to some information about, which bits of the underlying type might be used by the different options. But this is something **we wanted to abstract away in the first place**. So, there is a dilemma: on the one hand, we require a total order for sorted containers and sorting algorithms. But on the other hand, the use of this order in other places may indicate logical errors and should be prohibited.

To handle this Boost.Flags provides the following macros:

* `BOOST_FLAGS_DELETE_REL(E)`: deletes all relational operators for enumeration `E`
* `BOOST_FLAGS_SPECIALIZE_STD_LESS(E)`: specializes `std::less` for enumeration `E` to use the total order induced by the underlying values

The recommendation is defining both `BOOST_FLAGS_DELETE_REL(E)` and `BOOST_FLAGS_SPECIALIZE_STD_LESS(E)` as it allows standard sorting and sorted containers for `E` while disabling usage of relational operators in user code.


[NOTE]
====
In case `BOOST_FLAGS_DELETE_REL(E)` is defined, then for range-algorithms like `std::ranges::sort` the definition of `BOOST_FLAGS_SPECIALIZE_STD_LESS(E)` is unfortunately not sufficient. Range based algorithms by default use `std::ranges::less` as predicate, which eventually will call `operator <`, furthermore, `std::ranges::less` is not a template but a struct and cannot be specialized. 

So, to use range-algorithms in this case we have to provide the sort-predicate explicitly, which can be either `std::less<E>{}` or the generic xref:partial_order_t[`boost::flags::total_order`].
====


# Utilities

## Functions

All following utility functions are defined in `namespace boost::flags`. For an enabled enumeration `E`
Boost.Flags provides the following functions:


[cols="1,1,1"]
|===
|Name
|Type
|Definition

|`make_null`
|`(E) \-> E`
|`return E{};`

|`make_if`
|`(E e, bool set) \-> E`
|`return set ? e : E{};`

|`modify`
|`(E e, E mod, bool set)  \-> E`
|`return set ? e \| mod : e & ~mod;`

|`modify_inplace`
|`(E& e, E mod, bool set)  \-> E&`
|`e = modify(e, mod, set); return e;`

|`add_if`
|`(E e, E mod, bool add)  \-> E`
|`return add ? e \| mod : e;`

|`add_if_inplace`
|`(E& e, E mod, bool add)  \-> E&`
|`e = add_if(e, mod, add); return e;`

|`remove_if`
|`(E e, E mod, bool remove)  \-> E`
|`return remove ? e & ~mod : e;`

|`remove_if_inplace`
|`(E& e, E mod, bool remove)  \-> E&`
|`e = remove_if(e, mod, remove); return e;`

|`get_underlying`
|`(E e) \-> typename underlying_type<E>::type`
|`return static_cast<typename underlying_type<E>::type>(e);`

|`from_underlying`
|`(typename underlying_type<E>::type u) \-> E`
|`return static_cast<E>(u);`
|===


The macro `BOOST_FLAGS_USING_UTILITIES()` imports all utility functions, except `from_underlying`, through using-directives into the current namespace.

For generating the values of enumerators Boost.Flags provides furthermore:

* `template<typename T = int> nth_bit(unsigned int n) \-> underlying_or_identity<T>::type` +
returning the n-th power of 2
* `template<typename T> next_bit(T v) \-> underlying_or_identity<T>::type` +
returning the next power of 2 (if applied to a power of 2)

where type `T` can be either an enumeration or an integral type, and `underlying_or_identity` is a type-trait returning the underlying type of the enumeration or is the type-identity respectively

