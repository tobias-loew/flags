////
Copyright 2024, 2025 Tobias Loew

Distributed under the Boost Software License, Version 1.0.

See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt
////


// [#current_function_macro]
# Reference
:toc:
:toc-title:
:idprefix:

The contents of the library are in namespace boost::flags.

All operators and functions in this library

* are `constexpr` and `noexcept` 
* use attribute `nodiscard` except for operators / functions returning a reference to one of its arguments

At most places they are left out for readability. Furthermore, many function signatures for operators are written with trailing return type, where the leading `auto` is also left out for readability.

## Supported language versions

Boost.Flags requires at least C++11.

Concepts are used if available and not disabled by xref:BOOST_FLAGS_HAS_CONCEPTS[`BOOST_FLAGS_HAS_CONCEPTS`].

## Macros to opt-in


### BOOST_FLAGS

For an enumeration `E` at namespace scope the following variadic macro enables the operators of Boost.Flags
[source]
----
BOOST_FLAGS(E)
----

resp.

[source]
----
BOOST_FLAGS(E, OPTIONS)
----
where OPTIONS is an optional comma separated list containing at most one of each of the following options:

* `BOOST_FLAGS_PRE_INCREMENT`         : enables pre-increment `operator++` for `E` (see also xref:pre_increment[`pre_increment`])
* `BOOST_FLAGS_LOGICAL_AND`           : enables `operator&&` for `E` (see also xref:logical_and[`logical_and`])
* `BOOST_FLAGS_DISABLE_COMPLEMENT`    : disables the usage of `complement<E>` (see also xref:disable_complement[`disable_complement`])
* [[BOOST_FLAGS_NO_FORWARDING]]`BOOST_FLAGS_NO_FORWARDING`       : will not generate forwarding `friend` operators when using BOOST_FLAGS_LOCAL (has no effect for BOOST_FLAGS) (see also xref:Opt-in[Opt-in] and xref:BOOST_FLAGS_FORWARD_OPERATORS[`BOOST_FLAGS_FORWARD_OPERATORS`])


furthermore at most one of the following relational-operator options may be specified:

* `BOOST_FLAGS_DEFAULT_REL`                : use operators <, \<=, >, >= and \<\=> which accept two compatible flag-arguments and compare their underlying values (cf. xref:BOOST_FLAGS_SPECIALIZE_STD_LESS[`BOOST_FLAGS_SPECIALIZE_STD_LESS`])
* `BOOST_FLAGS_DELETE_REL`             : delete operators <, \<=, >, >= and \<\=> for type E (cf. xref:BOOST_FLAGS_DELETE_REL[`BOOST_FLAGS_DELETE_REL`])

If no relational-operator option is specified, `BOOST_FLAGS` defaults to using `BOOST_FLAGS_DEFAULT_REL`.

[NOTE]
====
When errors are encountered using `BOOST_FLAGS(E, ...)` this can have multiple reasons (list is not exhaustive):

* the invoked preprocessor is not standard conforming to at least C++11
* misspelling one of the options
* forgetting a comma or specifying a comma too much
* specifying the same options more than once
* specifying more than one relational-operator option
====

`BOOST_FLAGS(E)` imports all operators of Boost.Flags into the current namespace (cf. xref:BOOST_FLAGS_USING_OPERATORS[`BOOST_FLAGS_USING_OPERATORS()`]).


### BOOST_FLAGS_LOCAL

For an enumeration `E` at class scope use the following variadic macro to enables the operators of Boost.Flags
[source]
----
BOOST_FLAGS_LOCAL(E)
----

resp.

[source]
----
BOOST_FLAGS_LOCAL(E, OPTIONS)
----
enables all operators of Boost.Flags.

For the description of `OPTIONS` please refer to xref:BOOST_FLAGS[BOOST_FLAGS].

By default `BOOST_FLAGS_ENABLE_LOCAL(E)` creates friend functions for all operators of Boost.Flags for the enumeration `E` (cf. xref:BOOST_FLAGS_NO_FORWARDING[BOOST_FLAGS_NO_FORWARDING] and xref:BOOST_FLAGS_FORWARD_OPERATORS_LOCAL[BOOST_FLAGS_FORWARD_OPERATORS_LOCAL(E)]).


### Non-variadic macros for enabling

The following macros are primarily provided for non standard conforming preprocessors.

#### BOOST_FLAGS_ENABLE

For an enumeration `E` at namespace scope the macro 
[source]
----
BOOST_FLAGS_ENABLE(E)
----
enables all operators of Boost.Flags. +
`BOOST_FLAGS_ENABLE(E)` imports all operators of Boost.Flags into the current namespace (cf. xref:BOOST_FLAGS_USING_OPERATORS[BOOST_FLAGS_USING_OPERATORS()]).

#### BOOST_FLAGS_ENABLE_PRE_INCREMENT

For an enumeration `E` at namespace scope the macro 
[source]
----
BOOST_FLAGS_ENABLE_PRE_INCREMENT(E)
----
enables all operators of Boost.Flags and enables pre-increment `operator++` for `E` (see also xref:pre_increment[`pre_increment`]) +
`BOOST_FLAGS_ENABLE_PRE_INCREMENT(E)` imports all operators of Boost.Flags into the current namespace (cf. xref:BOOST_FLAGS_USING_OPERATORS[BOOST_FLAGS_USING_OPERATORS()]).



#### BOOST_FLAGS_ENABLE_LOGICAL_AND

For an enumeration `E` at namespace scope the macro 
[source]
----
BOOST_FLAGS_ENABLE_LOGICAL_AND(E)
----
enables all operators of Boost.Flags and enables `operator&&` for `E` (see also xref:logical_and[`logical_and`]) +
`BOOST_FLAGS_ENABLE_LOGICAL_AND(E)` imports all operators of Boost.Flags into the current namespace (cf. xref:BOOST_FLAGS_USING_OPERATORS[BOOST_FLAGS_USING_OPERATORS()]).



#### BOOST_FLAGS_ENABLE_DISABLE_COMPLEMENT

For an enumeration `E` at namespace scope the macro 
[source]
----
BOOST_FLAGS_ENABLE_DISABLE_COMPLEMENT(E)
----
enables all operators of Boost.Flags and disables the usage of `complement<E>` (see also xref:disable_complement[`disable_complement`]) +
`BOOST_FLAGS_ENABLE_DISABLE_COMPLEMENT(E)` imports all operators of Boost.Flags into the current namespace (cf. xref:BOOST_FLAGS_USING_OPERATORS[BOOST_FLAGS_USING_OPERATORS()]).


#### BOOST_FLAGS_ENABLE_...

the following macros provide combinations of the above macros:

* `BOOST_FLAGS_ENABLE_DISABLE_COMPLEMENT_LOGICAL_AND`
* `BOOST_FLAGS_ENABLE_DISABLE_COMPLEMENT_PRE_INCREMENT`
* `BOOST_FLAGS_ENABLE_LOGICAL_AND_PRE_INCREMENT`
* `BOOST_FLAGS_ENABLE_DISABLE_COMPLEMENT_LOGICAL_AND_PRE_INCREMENT`




#### BOOST_FLAGS_ENABLE_LOCAL

For an enumeration `E` at class scope the macro 
[source]
----
BOOST_FLAGS_ENABLE_LOCAL(E)
----
enables all operators of Boost.Flags. +
`BOOST_FLAGS_ENABLE_LOCAL(E)` creates friend functions for all operators of Boost.Flags for the enumeration `E` (cf. xref:BOOST_FLAGS_NO_FORWARDING[BOOST_FLAGS_NO_FORWARDING] and xref:BOOST_FLAGS_FORWARD_OPERATORS_LOCAL[BOOST_FLAGS_FORWARD_OPERATORS_LOCAL(E)]).


#### BOOST_FLAGS_ENABLE_LOCAL_PRE_INCREMENT

For an enumeration `E` at class scope the macro 
[source]
----
BOOST_FLAGS_ENABLE_LOCAL_PRE_INCREMENT(E)
----
enables all operators of Boost.Flags and enables pre-increment `operator++` for `E` (see also xref:pre_increment[`pre_increment`]) +
`BOOST_FLAGS_ENABLE_LOCAL_PRE_INCREMENT(E)` imports all operators of Boost.Flags into the current namespace (cf. xref:BOOST_FLAGS_USING_OPERATORS[BOOST_FLAGS_USING_OPERATORS()]).


#### BOOST_FLAGS_ENABLE_LOCAL_LOGICAL_AND

For an enumeration `E` at class scope the macro 
[source]
----
BOOST_FLAGS_ENABLE_LOCAL_LOGICAL_AND(E)
----
enables all operators of Boost.Flags and enables `operator&&` for `E` (see also xref:logical_and[`logical_and`]) +
`BOOST_FLAGS_ENABLE_LOCAL_LOGICAL_AND(E)` imports all operators of Boost.Flags into the current namespace (cf. xref:BOOST_FLAGS_USING_OPERATORS[BOOST_FLAGS_USING_OPERATORS()]).


#### BOOST_FLAGS_ENABLE_DISABLE_COMPLEMENT

For an enumeration `E` at class scope the macro 
[source]
----
BOOST_FLAGS_ENABLE_LOCAL_DISABLE_COMPLEMENT(E)
----
enables all operators of Boost.Flags and disables the usage of `complement<E>` (see also xref:disable_complement[`disable_complement`]) +
`BOOST_FLAGS_ENABLE_LOCAL_DISABLE_COMPLEMENT(E)` imports all operators of Boost.Flags into the current namespace (cf. xref:BOOST_FLAGS_USING_OPERATORS[BOOST_FLAGS_USING_OPERATORS()]).





#### BOOST_FLAGS_ENABLE_LOCAL_...

the following macros provide combinations of the above macros:

* `BOOST_FLAGS_ENABLE_LOCAL_DISABLE_COMPLEMENT_LOGICAL_AND`
* `BOOST_FLAGS_ENABLE_LOCAL_DISABLE_COMPLEMENT_PRE_INCREMENT`
* `BOOST_FLAGS_ENABLE_LOCAL_LOGICAL_AND_PRE_INCREMENT`
* `BOOST_FLAGS_ENABLE_LOCAL_DISABLE_COMPLEMENT_LOGICAL_AND_PRE_INCREMENT`



## Enabling helper functions, types and macros

[NOTE]
====
The functions, types and macros in this section are usually not used directly, but implicitly through one of the `BOOST_FLAGS...` macros.
====

### BOOST_FLAGS_USING_OPERATORS

The macro `BOOST_FLAGS_USING_OPERATORS()` imports all operators from `namespace boost::flags` into the current namespace. +
This enables https://en.cppreference.com/w/cpp/language/adl[ADL,window=_blank] for Boost.Flags operators for enumerations in the current namespace. 


### BOOST_FLAGS_USING_UTILITIES

The macro `BOOST_FLAGS_USING_UTILITIES()` imports all utility functions from `namespace boost::flags` into the current namespace. +
This enables https://en.cppreference.com/w/cpp/language/adl[ADL,window=_blank] for Boost.Flags utility functions for enumerations in the current namespace. 

### BOOST_FLAGS_USING_ALL

The macro `BOOST_FLAGS_USING_ALL()` is a shorthand for
[source]
----
BOOST_FLAGS_USING_OPERATORS()
BOOST_FLAGS_USING_UTILITIES()
----
(cf. xref:BOOST_FLAGS_USING_OPERATORS[BOOST_FLAGS_USING_OPERATORS] and xref:BOOST_FLAGS_USING_UTILITIES[BOOST_FLAGS_USING_UTILITIES])


### BOOST_FLAGS_FORWARD_OPERATORS

For an enumeration `E` the macro `BOOST_FLAGS_FORWARD_OPERATORS(E)` creates forwarding functions for all Boost.Flags operators for the enumeration `E` in the current namespace.


### BOOST_FLAGS_FORWARD_OPERATORS_LOCAL

For an enumeration `E` the macro `BOOST_FLAGS_FORWARD_OPERATORS_LOCAL(E)` creates forwarding friend functions for all Boost.Flags operators for the enumeration `E` in the current class / class template.

[NOTE]
====
Since the language does not allow `using` declarations at class scope, Boost.Flags uses `BOOST_FLAGS_FORWARD_OPERATORS_LOCAL` to ensure that all operators can be found through https://en.cppreference.com/w/cpp/language/adl[ADL,window=_blank].
====




### boost_flags_enable


The function `boost_flags_enable` can be overloaded for an enumeration `E` either 

* with return-type `std::integral_constant<bool, true>`:
+
[source]
----
constexpr std::integral_constant<bool, true> boost_flags_enable(E) { return {}; }
----
enables Boost.Flags for an enumeration `E`. All optional features are disabled.

* or with return-type `template<boost::flags::options Opts> boost::flags::options_constant`, where the 
 enumeration `boost::flags::options` has the following options:
** `enable`:  enables `E`
** `pre_increment`:  enables pre-increment`operator++` for `E` (see also xref:pre_increment[`pre_increment`])
** `disable_complement`:  disables the usage of `complement<E>` (see also xref:disable_complement[`disable_complement`])
** `logical_and`:  enables `operator&&` for `E` (see also xref:logical_and[`logical_and`])
e.g.
+
[source]
----
constexpr boost::flags::options_constant<
        boost::flags::options::enable               // enable E (required)
        | boost::flags::options::pre_increment      // enable pre-increment operator++
        | boost::flags::options::disable_complement // disable the usage of the complement
        | boost::flags::options::logical_and        // enable operator&&
    > 
        boost_flags_enable(E) { return {}; }
----

The function `boost_flags_enable` is looked up using https://en.cppreference.com/w/cpp/language/adl[ADL,window=_blank].

In case `E` is defined inside a class, a `friend` function can be used for enabling. E.g.

[source]
----
class my_class {
    // ...
    enum class E:unsigned int { ... };
    friend constexpr bool boost_flags_enable(E) { return true; }
    // ...
};
----

### enable<T>
[#types_enable]

Alternatively to `boost_flags_enable` an enumeration can be enabled by specializing the following template for an enumeration 

[source]
----
template<typename T> struct enable : std::false_type {};
----

and inherit from `std::true_type`.

Example:
[source]
----
enum class my_flags : unsigned int {
    option_a = 0x1,
    option_b = 0x2,
};

template<> struct boost::flags::enable<my_flags> : std::true_type {};
----

When `boost::flags::enable` is specialized for `E` any definition of `boost_flags_enable` for `E` are ignored
(cf. xref:boost_flags_enable[`boost_flags_enable`]).

In case variable templates are available (cf. xref:BOOST_FLAGS_HAS_VARIABLE_TEMPLATES[`BOOST_FLAGS_HAS_VARIABLE_TEMPLATES`]) then
[source]
----
template<typename E> 
constexpr bool enable_v = enable<E>::value;
----
is also provided.

[#pre_increment]
### pre_increment

If the specialization of `enable` inherits from `pre_increment` then pre-increment `operator++` is enabled.

Example:
[source]
----
template<> struct boost::flags::enable<E> 
    : std::true_type
    , boost::flags::pre_increment 
    {};
----



For an expression `e` of an enabled enumeration, the pre-increment operator wraps `++e` into an implementation defined type which has an `explicit operator bool()` and promotes the wrapped type through further bitwise operations. 
In boolean contexts, the expression `++e` is equivalent to `any(e)`.

(cf. xref:pre-increment operator++[pre-increment operator++] and xref:BOOST_FLAGS[`BOOST_FLAGS_PRE_INCREMENT`])


[#logical_and]
### logical_and

If the specialization of `enable` inherits from `logical_and` then `operator&&` is enabled.

Example:
[source]
----
template<> struct boost::flags::enable<E> 
    : std::true_type
    , boost::flags::logical_and 
    {};
----

(cf. #xref:logical_and[Logical `and`]# and xref:BOOST_FLAGS[`BOOST_FLAGS_LOGICAL_AND`])


[#disable_complement]
### disable_complement

If the specialization of class template `enable` inherits from `disable_complement` then the usage of the `complement` template (cf. xref:negation_operation[`operator~`]) is disabled.

When `disable_complement` is used, then the used enumeration must either be scoped, or has an explicit specified underlying type, otherwise the `operator~` may invoke undefined behavior (cf. xref:underlying_type[The underlying type] and xref:BOOST_FLAGS[`BOOST_FLAGS_DISABLE_COMPLEMENT`]).


## Types

[#complement]
### complement<T>

The template `complement` indicates that a value is the bitwise negation of a flag-value.
(Usually, the result of applying `operator~` to a flag-value.) It is used to distinguish flag-values from _negative masks_.

[source]
----
template<typename T> struct complement; 
----

By default the usage of `complement` is enabled, but can be disabled using xref:BOOST_FLAGS[`BOOST_FLAGS_DISABLE_COMPLEMENT`]. See also xref:negation_operation[`operator~`].



### total_order_t

The type `boost::flags::total_order_t` defines a call-operator which accepts two compatible flag-arguments and compares their underlying values.
There exists also a function object `total_order`:

`static constexpr boost::flags::total_order_t total_order;`

When xref:BOOST_FLAGS[`BOOST_FLAGS_DELETE_REL`] is specified, then `total_order` can be used as xref:overloading_relational_operators[_Compare_-predicate for range-algorithms].


## Operators

[#negation_operation]
### operator~

Reverses all bits of the underlying integer representation of its argument.

The signature of `operator~` depends on whether `complement` is enabled (cf. xref:BOOST_FLAGS[BOOST_FLAGS_DISABLE_COMPLEMENT]).

When `complement` is enabled for flags `E`

* `operator~(E) \-> complement<E>`
* `operator~(complement<E>) \-> E`

otherwise

* `operator~(E) \-> E`


### operator&

Applies a bitwise AND operation on the underlying integer representations of its arguments.

The signature of `operator&` depends on whether `complement` is enabled (cf. xref:BOOST_FLAGS[BOOST_FLAGS_DISABLE_COMPLEMENT]).

When `complement` is enabled for flags `E`

* `operator&(E, E) \-> E`
* `operator&(complement<E>, E) \-> E`
* `operator&(E, complement<E>) \-> E`
* `operator&(complement<E>, complement<E>) \-> complement<E>`

otherwise

* `operator&(E, E) \-> E`

All other viable `operator&` where at least one of the arguments is enabled for Boost.Flags and both are implicitly convertible to an integer type are deleted.


### operator|

Applies a bitwise OR operation on the underlying integer representations of its arguments.

The signature of `operator|` depends on whether `complement` is enabled (cf. xref:BOOST_FLAGS[BOOST_FLAGS_DISABLE_COMPLEMENT]).

When `complement` is enabled for flags `E`

* `operator|(E, E) \-> E`
* `operator|(complement<E>, E) \-> complement<E>`
* `operator|(E, complement<E>) \-> complement<E>`
* `operator|(complement<E>, complement<E>) \-> complement<E>`

otherwise

* `operator|(E, E) \-> E`

All other viable `operator|` where at least one of the arguments is enabled for Boost.Flags and both are implicitly convertible to an integer type are deleted.



### operator^

Applies a bitwise XOR operation on the underlying integer representations of its arguments.

The signature of `operator^` depends on whether `complement` is enabled (cf. xref:BOOST_FLAGS[BOOST_FLAGS_DISABLE_COMPLEMENT]).

When `complement` is enabled for flags `E`

* `operator^(E, E) \-> E`
* `operator^(complement<E>, E) \-> complement<E>`
* `operator^(E, complement<E>) \-> complement<E>`
* `operator^(complement<E>, complement<E>) \-> E`

otherwise

* `operator^(E, E) \-> E`

All other viable `operator^` where at least one of the arguments is enabled for Boost.Flags and both are implicitly convertible to an integer type are deleted.


### operator&=

Performs a bitwise AND assignment on the underlying integer representations of its arguments.

The signature of `operator&=` depends on whether `complement` is enabled (cf. xref:BOOST_FLAGS[BOOST_FLAGS_DISABLE_COMPLEMENT]).

When `complement` is enabled for flags `E`

* `operator&=(E&, E) \-> E&`
* `operator&=(E&, complement<E>) \-> E&`
* `operator&=(complement<E>&, complement<E>) \-> complement<E>&`

[NOTE]
====
The assignment `operator&=(complement<E>&, E)` is *not* available, as it would change the type of the first argument.
====

otherwise

* `operator&=(E&, E) \-> E&`




### operator|=

Performs a bitwise OR assignment on the underlying integer representations of its arguments.

The signature of `operator|=` depends on whether `complement` is enabled (cf. xref:BOOST_FLAGS[BOOST_FLAGS_DISABLE_COMPLEMENT]).

When `complement` is enabled for flags `E`

* `operator|=(E&,E) \-> E&`
* `operator|=(complement<E>&,E) \-> complement<E>&`
* `operator|=(complement<E>&,complement<E>) \-> complement<E>&`

[NOTE]
====
The assignment `operator|=(E&, complement<E>)` is *not* available, as it would change the type of the first argument.
====

otherwise

* `operator|=(E&,E) \-> E&`




### operator^=

Performs a bitwise XOR assignment on the underlying integer representations of its arguments.

The signature of `operator^=` depends on whether `complement` is enabled (cf. xref:BOOST_FLAGS[BOOST_FLAGS_DISABLE_COMPLEMENT]).

When `complement` is enabled for flags `E`

* `operator^=(E&,E) \-> E&`
* `operator^=(complement<E>&,E) \-> complement<E>&`

[NOTE]
====
The assignment `operator^=(E&, complement<E>)` and `operator^=(complement<E>&, complement<E>)` are *not* available, as they would change the type of the first argument.
====

otherwise

* `operator^=(E&,E) \-> E&`



### operator!

The `operator!` tests if a value is empty.

[source]
----
    // pseudo code
    bool operator!(E e) { return e == E{}; }
----


### pre-increment operator++

The pre-increment `operator++` wraps a value `e` of type `E` into an implementation defined type, with the following properties:

* has an `explicit operator bool`, such that in boolean contexts `+e` and `any(e)` yield the same result
* has an `explicit operator E`, which returns the value `e` back
* the wrapped type propagates through bitwise operators `&`, `|`, `^` and `~`, i.e. when at least one of their arguments is wrapped then the result is also wrapped
* the wrapping is idempotent, i.e. `+(+e)` is equivalent to `+e`

[source]
----
    // in boolean contexts
    if(+e) { ... }
    
    // is equivalent to
    if(any(e)) { ... }
----

[#BOOST_FLAGS_AND]
### Pseudo operator BOOST_FLAGS_AND

The pseudo operator `BOOST_FLAGS_AND` computes the bitwise AND of its arguments and converts the result to `bool`.

[source]
----
    // pseudo code
    bool operator BOOST_FLAGS_AND(E e1, E e2) { return any(e1 & e2); }
----

`BOOST_FLAGS_AND` has same precedence and associativity as `operator&`. It is a macro defined as +

[source]
----
#define BOOST_FLAGS_AND  & boost::flags::impl::pseudo_and_op_tag{} &
----


## operator== , operator!=

The description is provided only for `operator==`. Calls with reversed arguments and calls to `operator!=` are also available and return the respective results.

* `operator==(E, E) \-> bool`
* `operator==(complement<E>, complement<E>) \-> bool` 

equality is defined as usual by applying the operator to the underlying integer.

Furthermore the following overloads are defined

* `operator==(E, std::nullptr_t) \-> bool`
* `operator==(E, boost::flags::null_tag) \-> bool`

Both test for equality with an underlying value of `0`. The macro xref:BOOST_FLAGS_NULL[`BOOST_FLAGS_NULL`] defines an instance of `boost::flags::null_tag`.

All other viable `operator==` and `operator!=` where at least one of the arguments is enabled for Boost.Flags and both are implicitly convertible to an integer type are deleted.


[NOTE]
====
If `E` is a scoped enumeration then
[source]
----
    bool foo(E e){
        return e == 0;  // literal 0 converts to nullptr, thus
    }                   // operator==(E, std::nullptr_t) will be called
----
compiles and returns the expected result.

But, in case `E` is an unscoped enumeration then the above code will fail to compile, as the overload `operator(E, int)` is deleted for unscoped enumerations. (If it was not deleted, then `e` would implicitly convert to its underlying integer type and built-in `operator==` would step in. Thus, comparison with arbitrary integer values would be possible.)


====


## Utility functions

### any
[source]
----
    // pseudo code
    bool any(E e) { return e != E{}; }
----
Tests if a value is not empty.



### none
[source]
----
    // pseudo code
    bool none(E e) { return e == E{}; }
----
Tests if a value is empty.



### intersect
[source]
----
    // pseudo code
    bool intersect(E e1, E e2) { return e1 & e2 != E{}; }
----
Tests if two values have at least one common bits set.



### disjoint
[source]
----
    // pseudo code
    bool disjoint(E e1, E e2) { return e1 & e2 == E{}; }
----
Tests if two values do not have a common bit set.


### subseteq
[source]
----
    // pseudo code
    bool subseteq(E e1, E e2) { return e1 & e2 == e1; }
----
Tests if all bits set in the first argument are also set in the second argument.


### subset
[source]
----
    // pseudo code
    bool subset(E e1, E e2) { return subseteq(e1, e2) && (e1 != e2); }
----
Tests if the bits set in the first argument are a proper subset of the bits in the second argument.



### make_null

[source]
----
    // pseudo code
    E make_null(E) { return E{}; }
----

For flags `E` returns an _empty_ instance of type `E`, i.e. with underlying value `0`.  





### make_if

[source]
----
    // pseudo code
    E make_if(E e, bool set) { return set ? e : E{}; }
----

Depending on `set` returns either the first argument or empty an instance of type `E`.


### add_if

[source]
----
    // pseudo code
    E add_if(E e, E mod, bool add) { return add ? e | mod : e; }
----

Depending on `add` either adds all bits from `mod` to `e` or leaves `e` unmodified and returns the result.



### add_if_inplace

[source]
----
    // pseudo code
    E& add_if_inplace(E& e, E mod, bool add) { e = add_if(e, mod, add); return e; }
----

Similar to `add_if` but applies the modification to `e` and returns it as reference.



### remove_if

[source]
----
    // pseudo code
    E remove_if(E e, E mod, bool remove) { return remove ? e & ~mod : e; }
----

Depending on `remove` either removes all bits from `mod` from `e` or leaves `e` unmodified and returns the result.



### remove_if_inplace

[source]
----
    // pseudo code
    E& remove_if_inplace(E& e, E mod, bool remove) { e = remove_if(e, mod, remove); return e; }
----

Similar to `remove_if` but applies the modification to `e` and returns it as reference.



### modify

[source]
----
    // pseudo code
    E modify(E e, E mod, bool set) { return set ? e | mod : e & ~mod; }
----

Depending on `set` either adds or removes all bits from `mod` to `e` and returns the result.






### modify_inplace

[source]
----
    // pseudo code
    E& modify_inplace(E& e, E mod, bool set) { e = modify(e, mod, set); return e; }
----

Similar to `modify` but applies the modification to `e` and returns it as reference.






### get_underlying
Returns the underlying value. +
Let `U` be the underlying type of enabled enum `E`
[source]
----
    // pseudo code
    U get_underlying(E e) { return static_cast<U>(e); }
----

### from_underlying
Casts an value from underlying value the an enabled enum. +
Let `U` be the underlying type of enabled enum `E`
[source]
----
    // pseudo code
    E from_underlying(U u) { return static_cast<E>(u); }
----


### nth_bit

[source]
----
    // pseudo code
    template<typename T = int> 
    underlying_or_identity<T>::type nth_bit(unsigned int n) { 
        return static_cast<underlying_or_identity<T>::type>(1) << n; 
    }
----

Returns a value of type `T` with the n-th bit from the right set (zero-based) set.
The type `T` can be either an enumeration or an integral type, and `underlying_or_identity` is a type-trait returning the underlying type of the enumeration or it is the type-identity respectively.


### next_bit

[source]
----
    // pseudo code
    template<typename T> 
    T next_bit(T v) { return v << 1; }
----

Returns to a value `v` of type `T` the value with the next higher bit set (if available). +
The behavior is undefined if more than one bit is set in value `v`.


## Macros

### BOOST_FLAGS_NULL

The macro `BOOST_FLAGS_NULL` can be used for (in-)equality testing with a flag-value.

For any value `e` of type flags `E` the expression `e == BOOST_FLAGS_NULL` is equivalent to `e == E{}`. +
Similarly for  `e != BOOST_FLAGS_NULL`, `BOOST_FLAGS_NULL == e` and `BOOST_FLAGS_NULL != e`.


### BOOST_FLAGS_DELETE_REL

The macro `BOOST_FLAGS_DELETE_REL(E)` deletes all relational operators for a Boost.Flags enabled enumeration `E`. +
It must be defined at global namespace.


### BOOST_FLAGS_SPECIALIZE_STD_LESS

The macro `BOOST_FLAGS_SPECIALIZE_STD_LESS(E)` specialize std::less for E and complement<E> with the total order based on the value of the underlying integer type (i.e. `<` on the underlying integer type). +
It must be defined at global namespace.

[INFO]
====
The definition of `BOOST_FLAGS_SPECIALIZE_STD_LESS(E)` does not enable range algorithms to use that total order. For this purpose it is required to explicitly specify xref:total_order_t[`total_order`] as compare object.
====



## Library configuration macros

If not specified, all the following macros are deduced from the system, compiler, the C++ version and feature-test.
(Boost.Flags is tested with all major compilers on linux (ubuntu), macos and windows.)


### BOOST_FLAGS_HAS_THREE_WAY_COMPARISON

Specifies, if three way comparison (<\=>) is available.

Possible values: 0 or 1

### BOOST_FLAGS_HAS_PARTIAL_ORDERING

Specifies, if `std::partial_ordering` is available.

Possible values: 0 or 1


### BOOST_FLAGS_HAS_CONCEPTS

Specifies, if the compiler supports concepts.

Possible values: 0 or 1


### BOOST_FLAGS_HAS_IS_SCOPED_ENUM

Specifies, if `std::is_scoped_enum` is available.

Possible values: 0 or 1



### BOOST_FLAGS_HAS_LOGICAL_TRAITS

Specifies, if the logical traits `std::conjunction`, `std::disjunction` and `std::negation` are available.

Possible values: 0 or 1


### BOOST_FLAGS_HAS_REWRITTEN_CANDIDATES

Specifies, if https://en.cppreference.com/w/cpp/language/operators[rewitten candidates,window=_blank] are available.

Possible values: 0 or 1


### BOOST_FLAGS_HAS_VARIABLE_TEMPLATES

Specifies, if https://en.cppreference.com/w/cpp/language/variable_template[variable templates,window=_blank] are available.

Possible values: 0 or 1


### BOOST_FLAGS_ATTRIBUTE_NODISCARD

Text used as nodiscard attribute (e.g. `\[[nodiscard]]`).

### BOOST_FLAGS_ATTRIBUTE_NODISCARD_CTOR

Text used as nodiscard attribute for constructors (e.g. `\[[nodiscard]]`).

